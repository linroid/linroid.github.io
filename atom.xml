<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>linroid</title>
  <icon>https://www.gravatar.com/avatar/cdc3b5746102b1b6b90917847f93724a</icon>
  <subtitle>为小而美的应用奋斗!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://linroid.com/"/>
  <updated>2019-12-21T15:53:13.852Z</updated>
  <id>http://linroid.com/</id>
  
  <author>
    <name>linroid</name>
    <email>linroid@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Activity 的 onStop 居然需要 10s 才会被执行？</title>
    <link href="http://linroid.com/2018/08/10/onStop-executed-too-slowly/"/>
    <id>http://linroid.com/2018/08/10/onStop-executed-too-slowly/</id>
    <published>2018-08-10T02:15:27.000Z</published>
    <updated>2019-12-21T15:53:13.852Z</updated>
    
    <content type="html"><![CDATA[<p>由于我们的应用依赖 Activity 的 onStop 来停止播放器，近期发现退出直播间后，声音居然残留10s 左右，通过日志发现 Activity 的 onStop 在退出界面后需要10s左右才会被执行，该如何定位这个问题呢？<br><a id="more"></a><br>Activity 的 onStop 是放到 <code>IdleHandler</code> 执行的，所以退出界面后 onStop 不会立即执行，而是等到主线程中当前没有消息要执行的时候才会执行，具体可见我的另一篇文章分析：<a href="https://linroid.com/2017/05/24/Pit-of-Activity-destory/">Activity 销毁的延迟</a>。但必现 10s 左右才被执行肯定是异常的，可能有消息导致主线程一直没有 处理 IdleHandler，为验证这一点，可以在 onPause 的时候添加一个 IdleHandler 到主线程消息队列中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onPause();</span><br><span class="line">    Looper.myQueue().addIdleHandler(<span class="keyword">new</span> MessageQueue.IdleHandler() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">queueIdle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Log.i(TAG, <span class="string">"queueIdle after onPause"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果果然是在 onStop 之后才会被执行，所以可以确认是由于主线程一直有没有执行 IdleHandler 导致的，初步怀疑是有地方一直在往主线程 Looper 中 添加消息，接下来就需要定位是什么消息导致主线程一直处于非空闲状态。</p><p>我们可以通过 <code>Looper.setMessageLogging()</code> 来打印出主线程中执行的消息:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Looper.getMainLooper().setMessageLogging(<span class="keyword">new</span> Printer() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(String x)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (x.startsWith(<span class="string">"&gt;&gt;&gt;&gt;&gt;"</span>)) &#123;</span><br><span class="line">                Log.d(TAG, x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现有个动画组件的消息不停地被执行，移除这个动画组件后，问题依然存在，并且未发现其他比较明显的异常消息。</p><p><img src="https://cdn.linroid.com/WX20180723-105051@2x.png" alt></p><p>既然主线程中一直非空闲状态，那么我们就把主线程消息队列中的所有消息打印出来看看？</p><p>通过反射，可在每一帧的时候打印出主线程消息队列中的所有消息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Field messagesField;</span><br><span class="line"><span class="keyword">private</span> Field nextField;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        messagesField = MessageQueue.class.getDeclaredField("mMessages");</span><br><span class="line">        messagesField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        nextField = Message.class.getDeclaredField("next");</span><br><span class="line">        nextField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span> </span>&#123;        </span><br><span class="line">Choreographer.getInstance().postFrameCallback(<span class="keyword">new</span> Choreographer.FrameCallback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFrame</span><span class="params">(<span class="keyword">long</span> frameTimeNanos)</span> </span>&#123;</span><br><span class="line">                Choreographer.getInstance().postFrameCallback(<span class="keyword">this</span>);</span><br><span class="line">                Log.d(TAG, <span class="string">"doFrame"</span>);</span><br><span class="line">                printMessages();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printMessages</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MessageQueue queue = Looper.myQueue();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Message msg = (Message) messagesField.get(queue);</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span> (msg != <span class="keyword">null</span>) &#123;</span><br><span class="line">            sb.append(msg.toString());</span><br><span class="line">            sb.append(<span class="string">"\n"</span>);</span><br><span class="line">            msg = (Message) nextField.get(msg);</span><br><span class="line">        &#125;</span><br><span class="line">        Log.i(TAG, sb.toString());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到如下日志：<br><img src="https://cdn.linroid.com/blog/WX20180723-105818@2x.png" alt><br>可以看到消息队列的头部始终是一个 SyncBarrier 消息，有这个消息存在的时候，MessageQueue 只会取下一个 异步消息，让系统的 UI 事件消息得到优先处理。由此猜测，有地方不停地向 MessageQueue 中添加 SyncBarrier，通过对 <code>MessageQueue#postSyncBarrier()</code>方法打调试断点后，终于发现了罪魁祸首。</p><p><img src="https://cdn.linroid.com/blog/WX20180723-193912@2x.png" alt></p><p>查看代码后发现，虽然这位童鞋在收到 onGlobalLayout() 回调时的确调用了<code>View.getViewTreeObserver().removeOnGlobalLayoutListener()</code> ，但在上面截图中的 <code>fixBtnLayout</code>方法中又把监听器重新添加上了，所以实际并没有成功移除，相当于这里出现一个“异步的死循环“。</p><p>在 OnGlobalLayoutListener 中更新了布局的 LayoutParams 导致触发了 requestLayout()，而 requestLayout 会调用 <code>MessageQueue#postSyncBarrier()</code>，至于为什么主线程中有 SyncBarrier 消息时，IdleHandler 没有被执行的原因可以看 <code>MessageQueue#next()</code>的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If first time idle, then get the number of idlers to run.</span></span><br><span class="line"><span class="comment">// Idle handles only run if the queue is empty or if the first message</span></span><br><span class="line"><span class="comment">// in the queue (possibly a barrier) is due to be handled in the future.</span></span><br><span class="line"><span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span></span><br><span class="line">    &amp;&amp; (mMessages == <span class="keyword">null</span> || now &lt; mMessages.when)) &#123;</span><br><span class="line">    pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// No idle handlers to run.  Loop and wait some more.</span></span><br><span class="line">    mBlocked = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于这个时候是有消息的，所以 mMessages != null，由上面的日志可以看到 消息队列头部消息始终是 when 为负值，导致 <code>now &lt; mMessages.when</code> 也不成立，所以 pendingIdleHandlerCount 会一直为0，直到调用了 <code>MessageQueue#removeSyncBarrier()</code> 来移除 SyncBarrier 消息。</p><p>那么为什么 Activity 还是能回调 <code>onStop()</code> 呢？过滤掉 ActivityManager 的消息后可以看到一条这样的日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">W/ActivityManager: Launch timeout has expired, giving up wake lock!</span><br></pre></td></tr></table></figure><p>这是 ActivityManagerService 的超时机制，而这个时间正好是10s，具体可见 ActivityStack 中 <code>STOP_TIMEOUT</code>。超时后会把 Activity 强制置为 stop 状态，这时候不会再触发 onGlobalLayout，从而不会再有 SyncBarrier 消息，所以最终 IdleHandler 得到执行的机会。</p><h2 id="相关源码"><a href="#相关源码" class="headerlink" title="相关源码"></a>相关源码</h2><ul><li><a href="https://android.googlesource.com/platform/frameworks/base.git/+/master/services/core/java/com/android/server/am/ActivityStack.java" target="_blank" rel="noopener">ActivityStack.java</a></li><li><a href="https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/os/MessageQueue.java" target="_blank" rel="noopener">MessageQueue.java</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于我们的应用依赖 Activity 的 onStop 来停止播放器，近期发现退出直播间后，声音居然残留10s 左右，通过日志发现 Activity 的 onStop 在退出界面后需要10s左右才会被执行，该如何定位这个问题呢？&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Activity 销毁的延迟</title>
    <link href="http://linroid.com/2017/05/24/Pit-of-Activity-destory/"/>
    <id>http://linroid.com/2017/05/24/Pit-of-Activity-destory/</id>
    <published>2017-05-24T08:32:00.000Z</published>
    <updated>2019-12-21T15:53:13.850Z</updated>
    
    <content type="html"><![CDATA[<p>先看一张按下 Back 键之后，Activity 生命周期回调的日志截图：<br><img src="https://cdn.linroid.com/activity_back_pressed.png" alt="ActivityBackPressed"><br>从日志中可以看到当按下 Back 键时，当前的 Activity 会马上回调 onPause() 方法，而 onStop() 是在 MainActivity 的 onResume()之后才调用，onPause() 与 onStop()之间相隔了大约 300ms，也就是说 Activity 不是马上被销毁的。</p><p>再看另一个快速重新打开 <code>LifeActivity</code> 的 Case：<br><img src="https://cdn.linroid.com/quick_reopen_actiivty.png" alt="QuickReopenActivity"></p><blockquote><p>这里我采用代码模拟快速重新打开 <code>LifeActivity</code>，finish() 后延迟 300ms 再启动 <code>LifeActivity</code>。因为我们的 Activity 里没做什么事，所以很难手动重现快速重新打开 Activity 的异常 Case，而实际项目因为逻辑复杂，往往在1~2s或者更长的时间里很容易复现这种情况。</p></blockquote><p>出现了诡异的事：LifeActivity[33732136] 是旧的 Activity，但它却在新的 LifeActivity[212157058] 显示之后才被销毁的，看到这个可能你已经心头一凉。这会导致什么问题呢？这会让我们依赖 Activity 生命周期回调来做资源回收的代码变得不可靠。</p><p>举个栗子：如果我们在 onStart() 中启动相机在 onStop() 中关闭相机，正常重新打开这个页面时相机的状态操作：打开 -&gt; 关闭 -&gt; 打开，快速重新打开这个 Activity 时就可能不是这个顺序了：打开-&gt;打开-&gt;关闭。然后用户就遭殃了，他将无法正常使用你的应用了，而用户只是因为手速过快。<br><a id="more"></a></p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>那么为什么 onPause() 是马上被调用，而 onStop() 和 onDestroy() 却被延迟这么久呢？</p><blockquote><p>关于 Activity 销毁流程的源码我不会做详细分析，具体可以查看相关源码或者搜索其他人的文章看下</p></blockquote><p>调用 finish 方法后会经过以下流程向 <code>ActivityManagerService</code> 请求销毁当前 Activity：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MyActivity.finish() </span><br><span class="line">Activity.finish() </span><br><span class="line">ActivityManagerNative.getDefault().finishActivity() </span><br><span class="line">ActivityManagerService.finishActivity() </span><br><span class="line">ActivityStack.requestFinishActivityLocked() </span><br><span class="line">ActivityStack.finishActivityLocked() </span><br><span class="line">ActivityStack.startPausingLocked()</span><br></pre></td></tr></table></figure><p>然后 <code>ActivityManagerService</code> 就会请求执行当前 Activity 的 onPause() 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">IApplicationThread.schedulePauseActivity() </span><br><span class="line">ActivityThread.schedulePauseActivity() </span><br><span class="line">ActivityThread.sendMessage() </span><br><span class="line">ActivityThread.H.sendMessage() </span><br><span class="line">ActivityThread.H.handleMessage() </span><br><span class="line">ActivityThread.handlePauseActivity() </span><br><span class="line">ActivityThread.performPauseActivity() </span><br><span class="line">Instrumentation.callActivityOnPause() </span><br><span class="line">Activity.performPause() </span><br><span class="line">Activity.onPause() </span><br><span class="line">ActivityManagerNative.getDefault().activityPaused() </span><br><span class="line">ActivityManagerService.activityPaused() </span><br><span class="line">ActivityStack.activityPausedLocked() </span><br><span class="line">ActivityStack.completePauseLocked()</span><br></pre></td></tr></table></figure><p>所以 onPause() 是立即被执行的，执行完 onPause() 后并没有马上销毁 Activity，而是先让一个 Activity 显示出来，这个 Activity 可能是当前应用 Activity 栈中的一个 Activity 也可能是 Launcher 或者其他应用的 Activity，不管是哪个都大同小异，在上面的 Case 中就是 MainActivity。</p><p>执行上一个 Activity 即 MainActivity 的 onResume()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ActivityStack.resumeTopActivityLocked() </span><br><span class="line">ActivityStack.resumeTopInnerLocked() </span><br><span class="line">IApplicationThread.scheduleResumeActivity() </span><br><span class="line">ActivityThread.scheduleResumeActivity() </span><br><span class="line">ActivityThread.sendMessage() </span><br><span class="line">ActivityTherad.H.sendMessage() </span><br><span class="line">ActivityThread.H.handleMessage() </span><br><span class="line">ActivityThread.handleResumeActivity() </span><br><span class="line">Activity.performResume() </span><br><span class="line">Activity.performRestart() </span><br><span class="line">Instrumentation.callActivityOnRestart() </span><br><span class="line">Activity.onRestart() </span><br><span class="line">Activity.performStart() </span><br><span class="line">Instrumentation.callActivityOnStart() </span><br><span class="line">Activity.onStart() </span><br><span class="line">Instrumentation.callActivityOnResume() </span><br><span class="line">Activity.onResume()</span><br></pre></td></tr></table></figure><p>执行完上一个 Activity 的 onResume 之后，该进行 Activity 的销毁操作了吧？<br>通过反向分析，发现 Activity 的销毁时通过请求 ActivityManagerService 的 activityIdle() 方法，销毁流程如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Looper.myQueue().addIdleHandler(<span class="keyword">new</span> Idler()) </span><br><span class="line">ActivityManagerNative.getDefault().activityIdle() </span><br><span class="line">ActivityManagerService.activityIdle() </span><br><span class="line">ActivityStackSupervisor.activityIdleInternalLocked() </span><br><span class="line">ActivityStack.destroyActivityLocked() </span><br><span class="line">IApplicationThread.scheduleDestoryActivity() </span><br><span class="line">ActivityThread.scheduleDestoryActivity() </span><br><span class="line">ActivityThread.sendMessage() </span><br><span class="line">ActivityThread.H.sendMessage() </span><br><span class="line">ActivityThread.H.handleMessage() </span><br><span class="line">ActivityThread.handleDestoryActivity() </span><br><span class="line">ActivityThread.performDestoryActivity() </span><br><span class="line">Activity.performStop() </span><br><span class="line">Instrumentation.callActivityOnStop() </span><br><span class="line">Activity.onStop() </span><br><span class="line">Instrumentation.callActivityOnDestory() </span><br><span class="line">Activity.performDestory() </span><br><span class="line">Acitivity.onDestory() </span><br><span class="line">ActivityManagerNative.getDefault().activityDestoryed() </span><br><span class="line">ActivityManagerService.activityDestoryed() </span><br><span class="line">ActivityStack.activityDestoryedLocked()</span><br></pre></td></tr></table></figure><p>这个 Idler 实现的是 <code>MessageQueue.IdleHandler</code>，IdleHandler 会等到 MessageQueue 中当前没有可执行的消息时才会执行，也就是说 Activity 会一直等待主线程消息队列中当前消息都处理完毕了才会进行销毁，这也就是 Activity 的销毁不是立即执行的根本原因。</p><h1 id="如何避免"><a href="#如何避免" class="headerlink" title="如何避免"></a>如何避免</h1><p>手速快并不是用户的锅，要避免这种情况，可以用个静态变量保存当前 Activity，并且在销毁的时候判断下是不是与保存的一致，以下给出示例代码，如果你有更好的方案，欢迎告诉我 :)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LifeActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LifeActivity sCurrentLifeActivity;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        sCurrentLifeActivity = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart();</span><br><span class="line">        someResource.open();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStop();</span><br><span class="line">        <span class="keyword">if</span> (sCurrentLifeActivity == <span class="keyword">this</span>) &#123;</span><br><span class="line">            someResource.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        <span class="keyword">if</span> (sCurrentLifeActivity == <span class="keyword">this</span>) &#123;</span><br><span class="line">            sCurrentLifeActivity = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;先看一张按下 Back 键之后，Activity 生命周期回调的日志截图：&lt;br&gt;&lt;img src=&quot;https://cdn.linroid.com/activity_back_pressed.png&quot; alt=&quot;ActivityBackPressed&quot;&gt;&lt;br&gt;从日志中可以看到当按下 Back 键时，当前的 Activity 会马上回调 onPause() 方法，而 onStop() 是在 MainActivity 的 onResume()之后才调用，onPause() 与 onStop()之间相隔了大约 300ms，也就是说 Activity 不是马上被销毁的。&lt;/p&gt;
&lt;p&gt;再看另一个快速重新打开 &lt;code&gt;LifeActivity&lt;/code&gt; 的 Case：&lt;br&gt;&lt;img src=&quot;https://cdn.linroid.com/quick_reopen_actiivty.png&quot; alt=&quot;QuickReopenActivity&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这里我采用代码模拟快速重新打开 &lt;code&gt;LifeActivity&lt;/code&gt;，finish() 后延迟 300ms 再启动 &lt;code&gt;LifeActivity&lt;/code&gt;。因为我们的 Activity 里没做什么事，所以很难手动重现快速重新打开 Activity 的异常 Case，而实际项目因为逻辑复杂，往往在1~2s或者更长的时间里很容易复现这种情况。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;出现了诡异的事：LifeActivity[33732136] 是旧的 Activity，但它却在新的 LifeActivity[212157058] 显示之后才被销毁的，看到这个可能你已经心头一凉。这会导致什么问题呢？这会让我们依赖 Activity 生命周期回调来做资源回收的代码变得不可靠。&lt;/p&gt;
&lt;p&gt;举个栗子：如果我们在 onStart() 中启动相机在 onStop() 中关闭相机，正常重新打开这个页面时相机的状态操作：打开 -&amp;gt; 关闭 -&amp;gt; 打开，快速重新打开这个 Activity 时就可能不是这个顺序了：打开-&amp;gt;打开-&amp;gt;关闭。然后用户就遭殃了，他将无法正常使用你的应用了，而用户只是因为手速过快。&lt;br&gt;
    
    </summary>
    
    
      <category term="踩坑" scheme="http://linroid.com/tags/%E8%B8%A9%E5%9D%91/"/>
    
  </entry>
  
  <entry>
    <title>ArrayList 导致的内存泄露</title>
    <link href="http://linroid.com/2017/05/24/Memory-leak-caused-by-ArrayList/"/>
    <id>http://linroid.com/2017/05/24/Memory-leak-caused-by-ArrayList/</id>
    <published>2017-05-24T06:25:54.000Z</published>
    <updated>2019-12-21T15:53:13.849Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间在排查一处内存泄露时，发现是注册的一个监听器导致的。但检查了这个监听器在该取消注册的地方的确取消注册了，那内存中为什么还有它的引用呢？</p><a id="more"></a><p>分析内存发现是 ArrayList 对它进行了持有，但的确调用了 remove 来移除这个监听器呀。打断点发现注册监听器的方法被调用了两次，即调用了两次 ArrayList 的 add 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ArrayList 的 add 方法并没有进行去重操作，所以两次 add 都会成功。但 remove 方法却只调用了一次，来看看 remove 的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，remove 方法会遍历数组中的元素，一旦找到这个监听器，就会 return，即一次 remove 只会移除一个引用。但我们调用了两次 add 方法，所以 ArrayList 依然持有 这个监听器的引用。</p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><ul><li>在 add 的时候判断下 ArrayList 中是否已经存在这个对象，如果有则忽略这次操作</li><li>使用 HashSet 代替 ArrayList，HashSet 在添加的时候会进行去重</li></ul><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><p>  其实使用 ArrayList 来作为存放监听器的集合是很常见的，比如在 <code>RecyclerView</code>中 <code>mItemDecorations</code>、<code>mOnItemTouchListeners</code>、<code>mOnChildAttachStateListeners</code>、<br>  <code>mPendingAccessibilityImportanceChange</code>、<code>mScrollListeners</code> 等属性都是使用 ArrayList 来保存的，并且没有做去重处理。如果这个 ArrayList 放在单例中并且只 remove 了一次，重复的添加就会导致内存泄露；而在使用时的遍历又会因重复调用导致性能或其他问题。</p><p>  所以我们平时在遇到往 ArrayList 中添加对象时一定要注意这点，当然我个人更建议使用 HashSet 来保存，这样可以更好地避免团队里其他成员在使用时出现问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前段时间在排查一处内存泄露时，发现是注册的一个监听器导致的。但检查了这个监听器在该取消注册的地方的确取消注册了，那内存中为什么还有它的引用呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="内存泄露" scheme="http://linroid.com/tags/%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/"/>
    
  </entry>
  
  <entry>
    <title>「Wrapper」让你更愉快地调用 Listener</title>
    <link href="http://linroid.com/2017/03/19/introduce-wrapper/"/>
    <id>http://linroid.com/2017/03/19/introduce-wrapper/</id>
    <published>2017-03-19T06:11:22.000Z</published>
    <updated>2019-12-21T15:53:13.851Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在 <a href="https://github.com/linroid/Wrapper" target="_blank" rel="noopener">GitHub</a> 查看</p></blockquote><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>Android 开发中，会有很多情况下用到观察者模式，如果你自定义了一个 Listener，在需要调用他们来通知观察者时，或许会遇到以下几点头疼的问题：</p><ul><li><p>这个 Listener 是 Nullable 的，那么每次调用前都需要作判空处理</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (listener != <span class="keyword">null</span>) &#123;</span><br><span class="line">listener.foo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>事件是在其他线程中发出，而观察者需要在另一个线程中（通常是 UI 线程）处理，所以需要在每次调用的时候做 <code>Handler#post</code>操作</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(Looper.myLooper() != Looper.getMainLooper()) &#123;</span><br><span class="line">handler.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">listener.foo();</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">listener.foo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>如果观察者可以注册多个，那每次在调用的时候的时候都需要遍历一下所有 Listener</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">final</span> FooListener listener : listener) &#123;</span><br><span class="line">   listener.foo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>这三种情况可能会同时出现，比如在做与 Service 通信时是很常见的，如果回调方法更多时，代码写起来那是相当痛苦😂<br><a id="more"></a> </p><h1 id="造轮子"><a href="#造轮子" class="headerlink" title="造轮子"></a>造轮子</h1><p> 基于上面的原因，于是我撸一个轮子，就叫「Wrapper」。它利用 AnnotationProcessor 在构建过程中自动生成指定 Listener 的 Wrapper 类，在需要时只需简简单单的调用一下方法即可：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">listener.foo();</span><br></pre></td></tr></table></figure><p> Wrapper 会根据需要生成判空处理、post、遍历等代码，从编写繁琐无趣的代码中解放出来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WrapperClass</span></span><br><span class="line"><span class="meta">@WrapperMultiple</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SomeListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@UiThread</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onFoo</span><span class="params">(View view)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">onUserLeave</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过「Wrapper」的处理，会生成如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.linroid.wrapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Handler;</span><br><span class="line"><span class="keyword">import</span> android.os.Looper;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeListenerMultiWrapper</span> <span class="keyword">implements</span> <span class="title">SomeListener</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HashSet&lt;SomeListener&gt; _delegates = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Handler _handler;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SomeListenerMultiWrapper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>._handler = <span class="keyword">new</span> Handler(Looper.getMainLooper());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SomeListenerMultiWrapper</span><span class="params">(Handler _handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>._handler = _handler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">addWrapper</span><span class="params">(SomeListener _delegate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_delegate != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>._delegates.add(_delegate);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">removeWrapper</span><span class="params">(SomeListener _delegate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._delegates.remove(_delegate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onUserLeave</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">final</span> SomeListener _delegate : _delegates) &#123;</span><br><span class="line">            <span class="keyword">if</span> (_delegate != <span class="keyword">null</span>) &#123;</span><br><span class="line">                _delegate.onUserLeave();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFoo</span><span class="params">(<span class="keyword">final</span> View view)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Looper.myLooper() == <span class="keyword">null</span> || Looper.myLooper() != _handler.getLooper()) &#123;</span><br><span class="line">            _handler.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">final</span> SomeListener _delegate : _delegates) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (_delegate != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            _delegate.onFoo(view);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">final</span> SomeListener _delegate : _delegates) &#123;</span><br><span class="line">                <span class="keyword">if</span> (_delegate != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    _delegate.onFoo(view);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="使用「Wrapper」"><a href="#使用「Wrapper」" class="headerlink" title="使用「Wrapper」"></a>使用「Wrapper」</h1><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>在你的 <code>build.gradle</code>：<br>    <figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    annotationProcessor <span class="string">'com.linroid.wrapper:compiler:0.1.0'</span></span><br><span class="line">    compile <span class="string">'com.linroid.wrapper:library:0.1.0'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="可以使用的注解："><a href="#可以使用的注解：" class="headerlink" title="可以使用的注解："></a>可以使用的注解：</h2><ul><li><p><code>@WrapperClass</code> 对单个接口 / 类进行处理，默认只会进行判空处理</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WrapperClass</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SomeListener</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onFoo</span><span class="params">(View view)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>@UiThread</code> 需要进行 <code>Handler#post</code> 处理，可以用在方法或者类 / 接口上，如果用在类 / 接口，会对所有方法进行处理</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// @UiThread // 会对所有方法生效</span></span><br><span class="line"><span class="meta">@WrapperClass</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SomeListener</span> </span>&#123;</span><br><span class="line"><span class="meta">@UiThread</span> <span class="comment">// 只对指定方法生效</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onFoo</span><span class="params">(View view)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">onUserLeave</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>@WrapperMultiple</code> 支持多个 Listener</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WrapperClass</span></span><br><span class="line"><span class="meta">@WrapperMultiple</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SomeListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onFoo</span><span class="params">(View view)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>@WrapperGenerator</code> 与<code>@WrapperClass</code> 不同，你可以创建一个空的 Class，将所有需要处理的接口 / 类添加进来（这样就可以处理你无法修改的一些 Listener 了，比如 Android SDK 中的）。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WrapperGenerator</span>(</span><br><span class="line">        values = &#123;</span><br><span class="line">                View.OnClickListener<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line"><span class="class">                <span class="title">View</span>.<span class="title">OnLongClickListener</span>.<span class="title">class</span>,</span></span><br><span class="line"><span class="class">                <span class="title">MenuItem</span>.<span class="title">OnMenuItemClickListener</span>.<span class="title">class</span>,</span></span><br><span class="line"><span class="class">                <span class="title">View</span>.<span class="title">OnScrollChangeListener</span>.<span class="title">class</span></span></span><br><span class="line"><span class="class">        &#125;</span></span><br><span class="line"><span class="class">)</span></span><br><span class="line"><span class="class">@<span class="title">UiThread</span></span></span><br><span class="line"><span class="class">@<span class="title">WrapperMultiple</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">SomeGenerator</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h2><p>经过 Wrapper 的处理，会生成一个包名相同的 <code>XXXWrapper</code> 的类，如果添加了 <code>@ WrapperMultiple</code> 注解，会额外生成一个 <code>XXXMultiWrapper</code> 类。</p><p>需要注意的是，如果处理的是一个接口，那么生成的 Wrapper 会实现这个接口；而如果处理的是一个类，那么生成的 Wrapper 不会继承这个类。</p><p>添加完注解在执行一次 build 后，Wrapper 就会生成好相应的 <code>XXXWrapper</code> 类，使用它们非常简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SomeListenerWrapper wrapper = <span class="keyword">new</span> SomeListenerWrapper(listener);</span><br><span class="line"><span class="comment">// SomeListener wrapper = new SomeListenerWrapper(handler, listener); // 自己指定一个 Handler</span></span><br><span class="line">wrapper.setWrapper(listener); <span class="comment">// 设置你实现的 listener</span></span><br><span class="line">wrapper.onFoo(view); <span class="comment">// 调用方法</span></span><br><span class="line"></span><br><span class="line">SomeListenerMultiWrapper multiWrapper = <span class="keyword">new</span> SomeListenerMultiWrapper();</span><br><span class="line"><span class="comment">// SomeListenerMultiWrapper multiWrapper = new SomeListenerMultiWrapper(handler); // 自己指定一个 Handler</span></span><br><span class="line">multiWrapper.addWrapper(listener); <span class="comment">// 添加 listener</span></span><br><span class="line">multiWrapper.onFoo(view); <span class="comment">// 调用方法</span></span><br></pre></td></tr></table></figure><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>如果你有什么好的建议可以在评论留言，也可以提 <a href="https://github.com/linroid/Wrapper/pulls" target="_blank" rel="noopener">PR</a> :)<br>(嗯，我知道 kotlin 大法🐒</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在 &lt;a href=&quot;https://github.com/linroid/Wrapper&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt; 查看&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;Android 开发中，会有很多情况下用到观察者模式，如果你自定义了一个 Listener，在需要调用他们来通知观察者时，或许会遇到以下几点头疼的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;这个 Listener 是 Nullable 的，那么每次调用前都需要作判空处理&lt;/p&gt;
 &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (listener != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	listener.foo();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;事件是在其他线程中发出，而观察者需要在另一个线程中（通常是 UI 线程）处理，所以需要在每次调用的时候做 &lt;code&gt;Handler#post&lt;/code&gt;操作&lt;/p&gt;
 &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(Looper.myLooper() != Looper.getMainLooper()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	handler.post(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Runnable() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			listener.foo();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	listener.foo();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;如果观察者可以注册多个，那每次在调用的时候的时候都需要遍历一下所有 Listener&lt;/p&gt;
 &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; FooListener listener : listener) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   listener.foo();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这三种情况可能会同时出现，比如在做与 Service 通信时是很常见的，如果回调方法更多时，代码写起来那是相当痛苦😂&lt;br&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://linroid.com/tags/Android/"/>
    
      <category term="造轮子" scheme="http://linroid.com/tags/%E9%80%A0%E8%BD%AE%E5%AD%90/"/>
    
  </entry>
  
  <entry>
    <title>我的2016</title>
    <link href="http://linroid.com/2017/01/23/2016-summary/"/>
    <id>http://linroid.com/2017/01/23/2016-summary/</id>
    <published>2017-01-23T02:21:54.000Z</published>
    <updated>2019-12-21T15:56:22.029Z</updated>
    
    <content type="html"><![CDATA[<p>2016 年，在我人生中是变化很大的一年<br><a id="more"></a></p><p>首先我毕业了，学校的很多小伙伴们都很难再相见，很想念他们:)<br><img src="http://7u2rtn.com1.z0.glb.clouddn.com/21485138698_.pic_hd.jpg" alt="小伙伴们"></p><p>在学校的最后一段时间里认识我的她，我们一起毕业，一起经历由学生变成打工仔的过程。很高兴遇到你，我们的路还很长:)<br><img src="http://7u2rtn.com1.z0.glb.clouddn.com/zl_xy_graduation_photo.jpeg" alt="我们一起毕业"></p><p>辞了两次工作，一次是因为两千多公里的距离，一次是为了让自己过得更好</p><p>这一年中在技术上我开始更注重基础理论知识和架构设计，对过去追求的各种华丽的库兴趣逐渐下降。GitHub 上面的动态少了许多:(<br><img src="http://7u2rtn.com1.z0.glb.clouddn.com/WX20170123-110236@2x.png" alt="GitHub 2016"></p><p>工作上，开始注重与同事的相处，能够和产品撕逼</p><p>去过海边，坐过游轮，到过草原，玩过过山车，这次回家还能坐下飞机；经历过在北京的冬天里吃西瓜，广州的冬天里穿短袖=。=<br><a href="https://www.instagram.com/linroid/" target="_blank" rel="noopener">Instagram</a></p><p><img src="http://7u2rtn.com1.z0.glb.clouddn.com/linroid_instagram_2016.png" alt="Instagram 2016"></p><p>尝试自己做饭吃，虽然做得不好，但能让自己吃饱:)</p><hr><p>2017 年，希望自己能赚更多的钱：）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2016 年，在我人生中是变化很大的一年&lt;br&gt;
    
    </summary>
    
    
      <category term="总结" scheme="http://linroid.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>调用完 Handler#removeCallbacks() 就安全了吗?</title>
    <link href="http://linroid.com/2016/11/25/Safety-after-invoke-Handler-removeCallbacks/"/>
    <id>http://linroid.com/2016/11/25/Safety-after-invoke-Handler-removeCallbacks/</id>
    <published>2016-11-25T03:51:31.000Z</published>
    <updated>2019-12-21T15:53:13.850Z</updated>
    
    <content type="html"><![CDATA[<p>　　<code>Handler</code> 容易引起内存泄露，这是大家都知道的，所以你应该会在适当的时候调用 <code>removeCallbacks()</code> 方法来移除消息。但当以下使用场景时，依然可能会出现内存泄露。</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span> HandlerThread mDaemonHandler;</span><br><span class="line"></span><br><span class="line">Runnable mTimerRunnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    longTimeOperation();</span><br><span class="line">    Daemon.handler().postDelayed(<span class="keyword">this</span>, DELAY_INTERVAL);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestory</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">mDaemonHandler.removeCallbacks(mTimerRunnable)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>　　<code>mTimerRunnable</code> 是一个在非主线程中运行的循环操作，一旦启动了它，就会每隔 <code>DELAY_INTERVAL</code> 时间被执行一次，所以在 Activity 退出时，应该停止它，否则就会出现内存泄露。停止它的方式就是调用 <code>removeCallbacks()</code> 把它从<code>mDaemonHandler</code> 的消息队列中移除。<strong>但这一操作如果处在 <code>mDaemonHandler</code> 线程正在执行 <code>longTimeOperation()</code>时，<code>mTimerRunnable</code>之后还是会被添加到 <code>mDaemonHandler</code> 线程的消息队列中。</strong><br>　　<br>　　要保证消息能够移除掉，可以这样写：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> mDaemonHandler.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mDaemonHandler.removeCallbacks(mTimerRunnable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>　　这样就保证了移除 <code>mTimerRunnable</code> 的操作和 <code>mDaemonHandler</code> 在同一线程中，不会和 <code>mTimerRunnable</code> 『并发执行』。写成更通用的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> android.os.Handler;</span><br><span class="line"><span class="keyword">import</span> android.os.Looper;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> linroid &lt;linroid@gmail.com&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 25/11/2016</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SafetyUtils</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">removeCallbacks</span><span class="params">(<span class="keyword">final</span> Handler handler, <span class="keyword">final</span> Runnable callback)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (handler.getLooper() == Looper.myLooper()) &#123;</span><br><span class="line">            handler.removeCallbacks(callback);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            handler.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    handler.removeCallbacks(callback);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">removeMessages</span><span class="params">(<span class="keyword">final</span> Handler handler, <span class="keyword">final</span> <span class="keyword">int</span> what)</span> </span>&#123;</span><br><span class="line">        removeMessages(handler, what, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">removeMessages</span><span class="params">(<span class="keyword">final</span> Handler handler, <span class="keyword">final</span> <span class="keyword">int</span> what, <span class="keyword">final</span> Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (handler.getLooper() == Looper.myLooper()) &#123;</span><br><span class="line">            handler.removeMessages(what, obj);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            handler.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    handler.removeMessages(what, obj);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　&lt;code&gt;Handler&lt;/code&gt; 容易引起内存泄露，这是大家都知道的，所以你应该会在适当的时候调用 &lt;code&gt;removeCallbacks()&lt;/code&gt; 方法来移除消息。但当以下使用场景时，依然可能会出现内存泄露。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Handler" scheme="http://linroid.com/tags/Handler/"/>
    
      <category term="内存" scheme="http://linroid.com/tags/%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>Android Orientation 的坑</title>
    <link href="http://linroid.com/2016/11/09/Pit-of-Android-Orientation/"/>
    <id>http://linroid.com/2016/11/09/Pit-of-Android-Orientation/</id>
    <published>2016-11-09T02:41:40.000Z</published>
    <updated>2019-12-21T15:53:13.850Z</updated>
    
    <content type="html"><![CDATA[<p>　　最近在做 <a href="http://www.bigo.sg/index_pc.html" target="_blank" rel="noopener">Bigo Live</a> 直播间的横屏适配，横屏和竖屏下会有一些状态的差异。但我们的应用在横屏下，切换后台再回来后，发现一些状态显示不对。<br><a id="more"></a><br>　　猜想问题出现在了横竖屏状态判断上，先看下代码：<br>    <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOrientationPortrait</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getResources().getConfiguration().orientation == Configuration.ORIENTATION_PORTRAIT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　通过调试发现应用切后台之后， <code>isOrientationPortrait()</code> 会返回 true，于是换上另一种横竖屏判断：<br>    <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOrientationPortrait</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getRequestedOrientation() == ActivityInfo.SCREEN_ORIENTATION_PORTRAIT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　这两种方式的区别在于 <code>Configuration.orientation</code> 拿到的是设备的方向，而 <code>getRequestedOrientation()</code>拿到的是 Activity 请求的方向（通过<code>AndroidManifes.xml</code>中设置或者通过 <code>setRequestOrientation()</code> 改变)。<br>　　修改之后，应用处于后台时方向能判断正常，但一些后台时 <code>inflate</code> 的 View 却不正常或是抛出异常。于是写了一个 <code>Demo</code> 测试一下：<a href="https://gist.github.com/linroid/0c8086db0bcdf0abc7c1220cac4eb7da" target="_blank" rel="noopener">Gist</a>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">V/MainActivity: ⇢ onPause()</span><br><span class="line">D/MainActivity: getRequestedOrientation: landscape</span><br><span class="line">D/MainActivity: Configuration.orientation: landscape</span><br><span class="line">D/MainActivity: Layout View: landscape</span><br><span class="line">V/MainActivity: ⇠ onPause [2ms]</span><br><span class="line"></span><br><span class="line">V/MainActivity: ⇢ onStop()</span><br><span class="line">D/MainActivity: getRequestedOrientation: landscape</span><br><span class="line">D/MainActivity: Configuration.orientation: portrait</span><br><span class="line">D/MainActivity: Layout View: portrait</span><br><span class="line">V/MainActivity: ⇠ onStop [2ms]</span><br></pre></td></tr></table></figure></p><p>　　从中可以发现，从应用横屏状态切到后台 <code>Configuration.orientation</code> 会在 <code>onStop()</code>发生改变，而 <code>LayoutInflater#inflate()</code> 加载的 View 取决于<code>Configuration.orientation</code>，与 <code>getRequestedOrientation()</code>无关。</p><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>　　由 <code>LayoutInflater#inflate()</code> 可以找到布局文件路径是在 <code>Resources#loadXmlResourceParser()</code> 中拿到的：<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">XmlResourceParser <span class="title">loadXmlResourceParser</span><span class="params">(@AnyRes <span class="keyword">int</span> id, @NonNull String type)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> NotFoundException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> TypedValue value = obtainTempTypedValue();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> ResourcesImpl impl = mResourcesImpl;</span><br><span class="line">        impl.getValue(id, value, <span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        releaseTempTypedValue(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>ResourcesImpl#getValue()</code>：<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getValue</span><span class="params">(@AnyRes <span class="keyword">int</span> id, TypedValue outValue, <span class="keyword">boolean</span> resolveRefs)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> NotFoundException </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> found = mAssets.getResourceValue(id, <span class="number">0</span>, outValue, resolveRefs);</span><br><span class="line">    <span class="keyword">if</span> (found) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NotFoundException(<span class="string">"Resource ID #0x"</span> + Integer.toHexString(id));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>AssetsManager#getResourceValue()</code> 会调用 <code>AssetsManager#loadResourceValue()</code>，这是一个 Native 方法，那么 Native 层是怎样获取方向的呢？<br><code>ResourcesImpl#updateConfiguration()</code>：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateConfiguration</span><span class="params">(Configuration config, DisplayMetrics metrics,</span></span></span><br><span class="line"><span class="function"><span class="params">                        CompatibilityInfo compat)</span> </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">mAssets.setConfiguration(mConfiguration.mcc, mConfiguration.mnc,</span><br><span class="line">                    adjustLanguageTag(mConfiguration.getLocales().get(<span class="number">0</span>).toLanguageTag()),</span><br><span class="line">                    mConfiguration.orientation,</span><br><span class="line">                    mConfiguration.touchscreen,</span><br><span class="line">                    mConfiguration.densityDpi, mConfiguration.keyboard,</span><br><span class="line">                    keyboardHidden, mConfiguration.navigation, width, height,</span><br><span class="line">                    mConfiguration.smallestScreenWidthDp,</span><br><span class="line">                    mConfiguration.screenWidthDp, mConfiguration.screenHeightDp,</span><br><span class="line">                    mConfiguration.screenLayout, mConfiguration.uiMode,</span><br><span class="line">                    Build.VERSION.RESOURCES_SDK_INT);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>AssetsManager#setConfiguration()</code> 是 Native 层的方法，由此可以得出结论，Native 找到布局文件路径是通过 Configuration.orientation 来判断方向的，所以应用后台时会加载竖屏的资源。</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><ul><li><p>横竖屏的判断：<br>　　可以通过给 View 设置 Tag 或者判断某个 View 是否存在，来判断加载的是哪个状态的布局文件：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOrientationPortrait</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mRootView == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> getRequestedOrientation() == ActivityInfo.SCREEN_ORIENTATION_PORTRAIT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"port"</span> .equals(mRootView.getTag());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>后台时资源的加载：<br>如果你的应用处于横屏状态， 尽量不要在应用后台时加载与屏幕方向有关的资源，如果非要加载可以采取以下方法：</p><ul><li>将资源文件改为不同的名称（记得要都放到没有land标识的文件夹下，否则会出现 Resources#NotFoundException），然后根据方向判断加载哪一个。</li><li>通过反射方式修改 Native 层的屏幕方向：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定屏幕方向来加载资源</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> linroid &lt;linroid@gmail.com&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 09/11/2016</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrientationResourceLoader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">(Activity activity, Callback callback)</span> </span>&#123;</span><br><span class="line">        load(activity, activity.getRequestedOrientation() == ActivityInfo.SCREEN_ORIENTATION_PORTRAIT, callback);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">(Context context, <span class="keyword">boolean</span> isPortrait, @NonNull Callback callback)</span> </span>&#123;</span><br><span class="line">        Resources resources = context.getResources();</span><br><span class="line">        <span class="keyword">if</span> (isPortrait || context.getResources().getConfiguration().orientation == Configuration.ORIENTATION_LANDSCAPE) &#123;</span><br><span class="line">            callback.onLoad(context, resources);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Method updateConfiguration = resources.getClass()</span><br><span class="line">                    .getMethod(<span class="string">"updateConfiguration"</span>, Configuration<span class="class">.<span class="keyword">class</span>, <span class="title">DisplayMetrics</span>.<span class="title">class</span>)</span>;</span><br><span class="line">            Configuration configuration = <span class="keyword">new</span> Configuration(resources.getConfiguration());</span><br><span class="line">            DisplayMetrics displayMetrics = resources.getDisplayMetrics();</span><br><span class="line">            configuration.orientation = Configuration.ORIENTATION_LANDSCAPE;</span><br><span class="line">            updateConfiguration.invoke(resources, configuration, displayMetrics);</span><br><span class="line">            callback.onLoad(context, resources);</span><br><span class="line">            configuration.orientation = Configuration.ORIENTATION_PORTRAIT;</span><br><span class="line">            updateConfiguration.invoke(resources, resources.getConfiguration(), displayMetrics);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception error) &#123;</span><br><span class="line">            error.printStackTrace();</span><br><span class="line">            callback.onLoad(context, resources);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callback</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onLoad</span><span class="params">(Context context, Resources resources)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　最近在做 &lt;a href=&quot;http://www.bigo.sg/index_pc.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Bigo Live&lt;/a&gt; 直播间的横屏适配，横屏和竖屏下会有一些状态的差异。但我们的应用在横屏下，切换后台再回来后，发现一些状态显示不对。&lt;br&gt;
    
    </summary>
    
    
      <category term="踩坑" scheme="http://linroid.com/tags/%E8%B8%A9%E5%9D%91/"/>
    
  </entry>
  
  <entry>
    <title>此文献给我的强迫症</title>
    <link href="http://linroid.com/2016/08/31/Obsessive-compulsive-disorder/"/>
    <id>http://linroid.com/2016/08/31/Obsessive-compulsive-disorder/</id>
    <published>2016-08-31T03:30:05.000Z</published>
    <updated>2019-12-21T15:53:13.849Z</updated>
    
    <content type="html"><![CDATA[<p>　　最近又想拾起荒废已久的博客了，翻了下之前写的，看到中英文不空格、中英文符号掺杂这些很难忍受，于是默默开始修改…</p><p>　　我也有一些其他强迫症，比如代码中的空格（注释也不放过），不同编程语言会遵行不同的代码风格。一部分强迫症被强行扳正，比如应用里的小红点（当然，偶尔还是会清空一下=。=）；一部分强迫症是受其他人影响，比如中英文要空格是在知乎里养成的。</p><p>　　有的强迫症就跟信仰一样，不容冒犯，时刻约束着自己写出更『优雅』的代码。有的强迫症就是自己作死，心理会暗示自己去克服。</p><p>　　愿所有强迫症患者安好:)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　最近又想拾起荒废已久的博客了，翻了下之前写的，看到中英文不空格、中英文符号掺杂这些很难忍受，于是默默开始修改…&lt;/p&gt;
&lt;p&gt;　　我也有一些其他强迫症，比如代码中的空格（注释也不放过），不同编程语言会遵行不同的代码风格。一部分强迫症被强行扳正，比如应用里的小红点（当然，
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>设置界面中 SwitchCompat 无动画效果</title>
    <link href="http://linroid.com/2016/02/26/SwitchCompat-s-animation-not-work-in-Preference/"/>
    <id>http://linroid.com/2016/02/26/SwitchCompat-s-animation-not-work-in-Preference/</id>
    <published>2016-02-26T05:48:27.000Z</published>
    <updated>2019-12-21T15:53:13.851Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p> Support library 的 <code>SwitchCompat.java</code> :<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setChecked</span><span class="params">(<span class="keyword">boolean</span> checked)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.setChecked(checked);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Calling the super method may result in setChecked() getting called</span></span><br><span class="line">    <span class="comment">// recursively with a different value, so load the REAL value...</span></span><br><span class="line">    checked = isChecked();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (getWindowToken() != <span class="keyword">null</span> &amp;&amp; ViewCompat.isLaidOut(<span class="keyword">this</span>) &amp;&amp; isShown()) &#123;</span><br><span class="line">        animateThumbToCheckedState(checked);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Immediately move the thumb to the new position.</span></span><br><span class="line">        cancelPositionAnimator();</span><br><span class="line">        setThumbPosition(checked ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><a id="more"></a><p> Framework 的 <code>Switch.java</code><br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setChecked</span><span class="params">(<span class="keyword">boolean</span> checked)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.setChecked(checked);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Calling the super method may result in setChecked() getting called</span></span><br><span class="line">    <span class="comment">// recursively with a different value, so load the REAL value...</span></span><br><span class="line">    checked = isChecked();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isAttachedToWindow() &amp;&amp; isLaidOut()) &#123;</span><br><span class="line">        animateThumbToCheckedState(checked);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Immediately move the thumb to the new position.</span></span><br><span class="line">        cancelPositionAnimator();</span><br><span class="line">        setThumbPosition(checked ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> 可以看到 SwitchCompat 多了一个 <code>isShown()</code> 的判定条件</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the visibility of this view and all of its ancestors</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> True if this view and all of its ancestors are &#123;<span class="doctag">@link</span> #VISIBLE&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isShown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    View current = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">//noinspection ConstantConditions</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ((current.mViewFlags &amp; VISIBILITY_MASK) != VISIBLE) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ViewParent parent = current.mParent;</span><br><span class="line">        <span class="keyword">if</span> (parent == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// We are not attached to the view root</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!(parent <span class="keyword">instanceof</span> View)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        current = (View) parent;</span><br><span class="line">    &#125; <span class="keyword">while</span> (current != <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>isShown()</code> 会向上递归，如果 parent 为 null 就返回 false。<br>而 Preference 中，如果点击了，就会调用 <code>notifyDataSetChanged()</code> 刷新整个 RecyclerView，SwitchCompat 的 <code>setChecked()</code> 是在 <code>onBindViewHolder</code> 时调用的，这个时候还没有添加到 parent 中，所以 <code>isShown()</code> 就会 return false，从而动画不执行。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>  因为 Preference 的特殊性，所有状态改变都通过 <code>notifyDataSetChanged()</code> 来生效，所以这里通过以下 hack 的方式来解决，其他地方使用到 <code>SwitchCompat</code>立即 setChecked() 就不会出现这个问题</p><p>  创建 <code>SwitchCompatFixed</code>继承 SwitchCompat 重写<code>isShown()</code>方法<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isShown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ViewParent parent = getParent();</span><br><span class="line"><span class="keyword">if</span> (parent != <span class="keyword">null</span> &amp;&amp; parent <span class="keyword">instanceof</span> ViewGroup) &#123;</span><br><span class="line">ViewGroup widgetFrame = (ViewGroup) parent;</span><br><span class="line"><span class="keyword">if</span> (widgetFrame.getId() == android.R.id.widget_frame) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">super</span>.isShown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>   主题中修改 SwitchPreferenceCompat 的样式<br>   <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"switchPreferenceCompatStyle"</span>&gt;</span>@style/Preference.SwitchPreferenceCompatFixed<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>   定义样式<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"Preference.SwitchPreferenceCompatFixed"</span> <span class="attr">parent</span>=<span class="string">"Preference.SwitchPreferenceCompat"</span>&gt;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:layout"</span>&gt;</span>@layout/preference_material<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:widgetLayout"</span>&gt;</span>@layout/preference_widget_switch_fixed<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>创建布局文件<code>preference_widget_switch_fixed.xml</code><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">android.support.v7.widget.SwitchCompat</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/switchWidget"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:focusable</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:clickable</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:background</span>=<span class="string">"@null"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题分析&quot;&gt;&lt;a href=&quot;#问题分析&quot; class=&quot;headerlink&quot; title=&quot;问题分析&quot;&gt;&lt;/a&gt;问题分析&lt;/h2&gt;&lt;p&gt; Support library 的 &lt;code&gt;SwitchCompat.java&lt;/code&gt; :&lt;br&gt; &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;setChecked&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; checked)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;.setChecked(checked);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Calling the super method may result in setChecked() getting called&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// recursively with a different value, so load the REAL value...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    checked = isChecked();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (getWindowToken() != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; ViewCompat.isLaidOut(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;) &amp;amp;&amp;amp; isShown()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        animateThumbToCheckedState(checked);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Immediately move the thumb to the new position.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        cancelPositionAnimator();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        setThumbPosition(checked ? &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; : &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="遇过的坑" scheme="http://linroid.com/categories/%E9%81%87%E8%BF%87%E7%9A%84%E5%9D%91/"/>
    
    
  </entry>
  
  <entry>
    <title>xip.io + gradle 在调试时动态设置服务端地址</title>
    <link href="http://linroid.com/2015/07/24/dynamic-endpoint-when-debug-by-xip-io-and-gradle/"/>
    <id>http://linroid.com/2015/07/24/dynamic-endpoint-when-debug-by-xip-io-and-gradle/</id>
    <published>2015-07-24T11:25:55.000Z</published>
    <updated>2019-12-21T15:53:13.851Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>日常开发中，如果服务端在本地，通常可通过改hosts、写死IP、动态域名等方式来设置服务端地址，但总觉很麻烦，不灵活；比如更换网络导致IP变化，就得重新设置。<br>今天突然想到，利用xip.io 和 gradle来自动设置服务端地址</p></blockquote><a id="more"></a><p> <a href="http://xip.io" target="_blank" rel="noopener">xip.io</a> 是一个直接使用域名来指定 IP 的域名服务，无需手动设置 DNS，同时也不需要任何注册。这解决了使用 IP 无法使用多个 Virtual Host 而使用域名又得很麻烦改地DNS的问题。</p><p> xip.io 支持 <code>{custom_prefix}.{host_ip}.xip.io</code> 的域名格式，解析出来的 ip 就是 {host_id}。如:</p><p> <code>exmple.com.127.0.0.1.xip.ip</code> 会解析为<code>127.0.0.1</code></p><p> 下面进行 gradle 配置:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> buildTypes &#123;</span><br><span class="line">  debug &#123;</span><br><span class="line">    //...</span><br><span class="line">    def hostIp = InetAddress.getLocalHost().getHostAddress()</span><br><span class="line">    buildConfigField &quot;String&quot;, &quot;ENDPOINT&quot;, &quot;\&quot;http://example.com.$&#123;hostIp&#125;.xip.io/api\&quot;&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  release &#123;</span><br><span class="line">//...</span><br><span class="line">    buildConfigField &quot;String&quot;, &quot;ENDPOINT&quot;, &quot;\&quot;http://example.com/api\&quot;&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 在 debug 下，gradle 会获取当前电脑的 IP，然后写入到 BuildConfig 类中的 <code>ENDPOINT</code> 属性。gradle sync 一下后，<code>BuildConfig.ENDPOINT</code> 就被赋值为 <code>http://example.com.${hostIp}.xip.io/api</code></p><p> 当然，还可以放到 xml 文件中:)</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resValue &quot;string&quot;, &quot;host_url&quot;, &quot;http://example.com.$&#123;hostIp&#125;.xip.io&quot;;</span><br></pre></td></tr></table></figure><p> 最后记得在 apache/nginx 等配置 Virtual Host 时使用宽域名，如 Nginx 中:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server_name example.com.*</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;日常开发中，如果服务端在本地，通常可通过改hosts、写死IP、动态域名等方式来设置服务端地址，但总觉很麻烦，不灵活；比如更换网络导致IP变化，就得重新设置。&lt;br&gt;今天突然想到，利用xip.io 和 gradle来自动设置服务端地址&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="瞎折腾" scheme="http://linroid.com/categories/%E7%9E%8E%E6%8A%98%E8%85%BE/"/>
    
    
      <category term="Android Studio" scheme="http://linroid.com/tags/Android-Studio/"/>
    
      <category term="gradle" scheme="http://linroid.com/tags/gradle/"/>
    
  </entry>
  
  <entry>
    <title>Git 在 OSX 中的提交忽略文件名称大小写</title>
    <link href="http://linroid.com/2015/07/18/git-ignorecase/"/>
    <id>http://linroid.com/2015/07/18/git-ignorecase/</id>
    <published>2015-07-18T15:21:20.000Z</published>
    <updated>2019-12-21T15:56:22.030Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7u2rtn.com1.z0.glb.clouddn.com/Snip20150718_8.png" alt="image"><br>看到<a href="https://github.com/drakeet" target="_blank" rel="noopener">drakeet</a>的<a href="https://github.com/drakeet/Meizhi" target="_blank" rel="noopener">妹纸</a> App，想写个 iOS 版拿来练手。开始时项目命名为 <code>MeiZhi</code>，然后发现drakeet的是<code>Meizhi</code>，所以我也改为<code>Meizhi</code>来保持一致。在 GitHub 上查看时发现名称并没有改变，原因是git默认忽略了大小写。<br><a id="more"></a><br>设置 git 大小写敏感:</p><p><code>git config core.ignorecase false</code></p><p>push后，在GitHub上查看，发现<code>Meizhi</code>和<code>MeiZhi</code>等都同时存在，而自己在本地 ls 并没有异常。OSX 的文件名大小写不敏感但大小写保留，所以并没有都显示出来。</p><p><strong>解决</strong>:</p><p><img src="http://7u2rtn.com1.z0.glb.clouddn.com/Snip20150718_5.png" alt="image"><br>ssh 到 vps 上，clone 代码，然后删除重复的文件，再 push 到 GitHub。<br><img src="http://7u2rtn.com1.z0.glb.clouddn.com/Snip20150718_7.png" alt="image"><br>本地 pull 后，<code>Meizhi</code> 目录也不存在了，<code>git status</code> 查看，显示被删除，使用 <code>git reset ./</code> 来恢复</p><p>之后如果再遇到只修改字母大小时可以通过 <code>git mv --force FileName Filename</code> 来避免这个问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7u2rtn.com1.z0.glb.clouddn.com/Snip20150718_8.png&quot; alt=&quot;image&quot;&gt;&lt;br&gt;看到&lt;a href=&quot;https://github.com/drakeet&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;drakeet&lt;/a&gt;的&lt;a href=&quot;https://github.com/drakeet/Meizhi&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;妹纸&lt;/a&gt; App，想写个 iOS 版拿来练手。开始时项目命名为 &lt;code&gt;MeiZhi&lt;/code&gt;，然后发现drakeet的是&lt;code&gt;Meizhi&lt;/code&gt;，所以我也改为&lt;code&gt;Meizhi&lt;/code&gt;来保持一致。在 GitHub 上查看时发现名称并没有改变，原因是git默认忽略了大小写。&lt;br&gt;
    
    </summary>
    
      <category term="遇过的坑" scheme="http://linroid.com/categories/%E9%81%87%E8%BF%87%E7%9A%84%E5%9D%91/"/>
    
    
      <category term="git" scheme="http://linroid.com/tags/git/"/>
    
      <category term="OSX" scheme="http://linroid.com/tags/OSX/"/>
    
  </entry>
  
  <entry>
    <title>找实习的那点事</title>
    <link href="http://linroid.com/2015/05/22/Internship-interview/"/>
    <id>http://linroid.com/2015/05/22/Internship-interview/</id>
    <published>2015-05-22T09:15:27.000Z</published>
    <updated>2019-12-21T15:56:22.030Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7u2rtn.com1.z0.glb.clouddn.com/IMG20150507154554.jpg" alt="阿里包包~"><br>  拖延症晚期，所以现在才找到已闲置很久的博客，把自己找实习的过程写下来( hexo 都更新一个版本号了:)<br><a id="more"></a><br>  去年暑假时出去实习过两个月，不过那是通过老师认识的一个人，直接去的，结果被坑得巨惨，这次大三，要认真的找一家自己想去的公司了。</p><p>寒假时参考着 <a href="https://github.com/geekcompany/ResumeSample/blob/master/android.md" target="_blank" rel="noopener">Android程序员简历模板</a> 开始写自己的简历，3.3日收到三翼的老人肖彬学长的阿里巴巴内推邮件，由此进入了找实习的苦逼日子。简历通过，进入内推的电话面试阶段，当时很高兴的还截图发了朋友圈，结果作为处女面，被面试官完虐，这里不得不感叹下阿里招聘系统的效率，挂完电话十多分钟就出面试结果，迅速泯灭了自己的侥幸心理。</p><p>  面试失败的挫败感让自己开始反思，搜了一些面经，看到一句话: <code>经验并不能代表能力</code>。看着自己简历上的项目经历，挺多。然而自己面试时候连大端、小端这样的基础问题都没回答上来，深感自己就是传说中的“码农”。于是开始补基础，不能让自己输的太惨。看了以下的几本书：</p><ul><li>《深入理解计算机系统》</li><li>《算法导论》</li><li>《算法》</li><li>《深入理解Java虚拟机》</li><li>《现代操作系统》</li></ul><p> 带着目的挑了一些觉得可能面试会问到的内容看(今后一定要认真啃完这些书！一定！！！)。</p><p> 那段时间，知乎<a href="http://www.zhihu.com/people/fkysly" target="_blank" rel="noopener">马天翼</a>刚拿到阿里的实习 offer，正在他建的群里帮 winter 大大招实习生，同学看到后向他吹了我几句，然后让我联系他。发了简历后，肯定了我几句，说一定能进阿里，并把简历转交给 winter 了。几天后趴在教室座位熟睡时，接到另一位工程师的电面，这次的感觉语气轻多了，问的问题如 Android 架构分层的好处、Retrofit 的缺点如果让我设计会怎样设计，聊了聊开源的东西。最后因为过了内推时间，他让我再参加正常的实习生校招流程，于是进入阿里校招官网再次投递…</p><p> 接着投了豆瓣，笔试题很简单，两道算法二选一，剩下的都是 Android 基础问题,题目有些多，1个小时答题时间，最后没做完。</p><p> 某天心血来潮，厚着脸皮，QQ 上找 <a href="http://weibo.com/issacsuixing" target="_blank" rel="noopener">@碎碎iKe</a> 要了豌豆荚和小米的推荐。豌豆荚很速度，HR隔天就联系我预约了电面时间。豌豆荚的电面每轮一小时左右，都有在线 coding 阶段(通过 <a href="http://collabedit.com/" target="_blank" rel="noopener">collabedit</a> 这个网站)。过了三次电面，需要我去北京现场参加面试 ( 报销来往高铁票和一晚的住宿费好评！)。</p><p> 去北京之前进行了豆瓣的电面，问的都是 Android 方面的内容，回答的很顺畅。</p><p> 提前来到贵荚公司附近，被周围的环境惊艳到了，可以秒杀很多公园，让我对贵荚更加向往了。现场面的第一轮是位姐姐，面试过程就跟普通聊天一样，还表扬了我UI方面的知识。第二轮的面试官一上来就让在纸上写代码，都不知道自己当时哪来的自信写完没检查就给他看了，结果漏洞百出=_=，然后全程紧张，问的思维题完全没思路。<br>  <img src="http://7u2rtn.com1.z0.glb.clouddn.com/IMG_20150419_082209.jpg" alt="一个人瞎逛"><br>  <img src="http://7u2rtn.com1.z0.glb.clouddn.com/IMG_20150418_145928.jpg" alt="不到长城非好汉"><br> 在北京浪了两天一个人爬了长城、看了速7，坐高铁回学校的途中通过云招求职的微信号查到了自己的面试结果：已拒绝。当时感觉比失恋还难受，很受打击。</p><p> 回到学校后，不想看书，玩了几天游戏，想想挂在第五面就心累…</p><p> 然后QQ突然收到小米HR的加好友请求，都一个月了啊，才联系我=_=于是又被小米的工程师进行电面，那个面试官感觉水平很一般，几个问题都是问我时“xx 会不会”，我说会，并且进行了一些说明，并没有追问我其他的，问的问题都是非常基础的东西。</p><p> 有意思的是某天玩无秘时，在自己加的一个 BAT 的群里问了下有谁要实习生不，结果真有一个人私聊了我，加了微信，然后让我发把简历发到 email，根据 email 知道他居然是新美互通的一个联合创始人(本只是个外包公司的,新美互通的产品有几亿用户呢，主要做海外市场，Android 上的字体管家就是他们做的，还有一个输入法在 play 工具免费榜排前十)。电面的过程也没难度，问的都是 Android 方面的~随后通知通过了电面，让我去北京面试，又是可以报销高铁啊，哈哈，IT 公司就是财大气粗。</p><p>  5.3 离开学校和三翼的老大一起去广州参加阿里的现场面试，因为当时有可能拿到豆瓣、小米、新美互通等公司 offer，所以对这次面试并不是特在意，即使失败，也应该有一家收留吧(╥﹏╥)（其实是奔着想去陌生的广州耍耍的，所以面试地点选择了更远的广州，去的时候坐的绿皮车真够折腾的…）。在酒店等待被呼叫的过程中，还接到豆瓣HR的电话，说我通过了面试，要给我 offer。心中一阵狂喜啊，终于有人收留了！！！</p><p> <img src="http://7u2rtn.com1.z0.glb.clouddn.com/IMG_20150505_131837.jpg" alt="阿里面试等候区"><br>  阿里的这次面试太幸运了，很感谢第一轮的面试官，把简历递给他时，一行一行指着看，每个链接都手动输入到电脑查看。在他看我 GitHub 时就感觉有戏了，他的话语让我并没有觉得很紧张，还说发现我的 commit 大部分都是中午和晚上,认真吧！！！不过我也犯傻了，问了我一道判断链表环路的算法，因为之前豌豆的电面被问过，当他说说完问题后，我就立马说出了思路，他也立马就换题了=_=然后我没做出来，不过他连忙说没事没事。二面的面试官问的都是关于项目经验的了，很轻松的过了。不过刚回到等待室就被通知进行下一场面试( HR 面)，都没来得及喝水啊!!! 面试官姐姐看出来了，给我拿了杯水，太感动了，哈哈。问的问题不算刁难，各个方面的问题都有，自己回答的挺谨慎，生怕哪个问题回答得与 HR 三观不符被刷了　(´Д` )。<br> <img src="http://7u2rtn.com1.z0.glb.clouddn.com/IMG_20150507_101451.jpg" alt="圆桌沙龙的anli现场"><br>  晚上收到短信通过了阿里面试，发朋友圈秀一下！嘿。第二天早上又收到小米 HR 的电话，给我 offer，问我入职的事(什么鬼，之前说肯定有现场面试啊，结果一轮就让我过了 =_=? 真是人品爆发啊)。至此已经有了豆瓣、小米、阿里的 offer，果断拒绝了新美的面试。参加阿里的圆桌沙龙被 anli 后，便拒绝了小米和豆瓣 的 offer～。</p><p>  以上就是我找实习的流水账了（深感不如小学生作文水平，看来以后要多码字了），总结起来，要重视基础，不然会死得很惨；面试机会有很多途径，自己去争取，比如我就从无秘拿到了；内推可以省去很多麻烦，如果有不错的成就很容易拿到内推，我大概是靠 GitHub 上700多的 star 拿的内推；不要太在意一场面试，机会还有很多，太在意可能会过于紧张导致发挥失常；平时多积攒人品…</p><p>  <strong>附上一些很有用的一些资源:</strong></p><ul><li><p><a href="http://www.codekk.com/open-source-project-analysis" target="_blank" rel="noopener">codeKK 开源项目源码分析</a> 能对源码分析，面试时可以给面试官很好的印象~</p></li><li><p><a href="https://github.com/HIT-Alibaba/interview/wiki" target="_blank" rel="noopener">IT/互联网笔试面试知识整理</a></p></li><li><p><a href="http://www.cs.usfca.edu/~galles/visualization/Algorithms.html" target="_blank" rel="noopener">Data Structure Visualizations</a> 数据结构可视化，很叼啊!</p></li><li><p><a href="https://github.com/pedrovgs/Algorithms" target="_blank" rel="noopener">pedrovgs/Algorithms</a> 常用算法的Java实现</p></li><li><p><a href="https://oj.leetcode.com/" target="_blank" rel="noopener">leetcode</a> 面试遇到的算法题很多都在上面，相比ACM的OJ更人性化；平时就练练，每道题弄透。</p></li><li><p><a href="http://blog.csdn.net/v_july_v" target="_blank" rel="noopener">结构之法 算法之道</a> 很多人推荐的</p></li><li><a href="https://github.com/android-cn/android-discuss/issues" target="_blank" rel="noopener">android-cn/android-discuss</a>  Trinea 大牛建的一个库，讨论Android面试的一些问题^_^</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7u2rtn.com1.z0.glb.clouddn.com/IMG20150507154554.jpg&quot; alt=&quot;阿里包包~&quot;&gt;&lt;br&gt;  拖延症晚期，所以现在才找到已闲置很久的博客，把自己找实习的过程写下来( hexo 都更新一个版本号了:)&lt;br&gt;
    
    </summary>
    
      <category term="整理总结" scheme="http://linroid.com/categories/%E6%95%B4%E7%90%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="实习" scheme="http://linroid.com/tags/%E5%AE%9E%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>提交 library 项目到 Maven Central</title>
    <link href="http://linroid.com/2015/03/13/upload-android-library-to-moven-central/"/>
    <id>http://linroid.com/2015/03/13/upload-android-library-to-moven-central/</id>
    <published>2015-03-13T02:51:42.000Z</published>
    <updated>2019-12-21T15:56:22.031Z</updated>
    
    <content type="html"><![CDATA[<p>  将 <a href="http://github.com/linroid/FilterMenu" target="_blank" rel="noopener">FilterMenu</a> 提交到 GitHub 后，在 README.md 的 Getting Started 里仅仅写上</p><blockquote><p>Download the source to use it as library project</p></blockquote><p>  这唯一使用途径，居然没有 gradle/maven ?作为 Android Studio 的忠实用户，自己写的库怎么能只提供这么麻烦的方法！！！于是决定把它提交到 Maven Central 中。<br><a id="more"></a></p><p>虽然 AS 的 gradle 默认使用的是 jcenter 仓库，但我们只需要提交到 Maven Central 即可，jcenter 会自动同步。  </p><p><strong>如果还没有账号先去 Maven Central 注册: <a href="https://issues.sonatype.org/secure/Signup!default.jspa" target="_blank" rel="noopener">Sign up</a> </strong></p><p>并到 <a href="https://issues.sonatype.org/secure/CreateIssue.jspa?issuetype=21&amp;pid=10134" target="_blank" rel="noopener">Create Issue</a> 提交工单等待管理员的回复，填 groupId 时，请使用顶级 groupId，比如我只需要填写 <code>com.linroid</code>，就可以发布到任何 <code>com.linroid.*</code> 下的groupId。</p><p>我是早上提交的，到晚上0:30的时候收到回复。<a href="http://central.sonatype.org/articles/2014/Feb/27/why-the-wait/" target="_blank" rel="noopener">Why the wait?</a></p><blockquote><p>Configuration has been prepared, now you can:<br>Deploy snapshot artifacts into repository <a href="https://oss.sonatype.org/content/repositories/snapshots" target="_blank" rel="noopener">https://oss.sonatype.org/content/repositories/snapshots</a><br>Deploy release artifacts into the staging repository <a href="https://oss.sonatype.org/service/local/staging/deploy/maven2" target="_blank" rel="noopener">https://oss.sonatype.org/service/local/staging/deploy/maven2</a><br>Promote staged artifacts into repository ‘Releases’<br>Download snapshot and release artifacts from group <a href="https://oss.sonatype.org/content/groups/public" target="_blank" rel="noopener">https://oss.sonatype.org/content/groups/public</a><br>Download snapshot, release and staged artifacts from staging group <a href="https://oss.sonatype.org/content/groups/staging" target="_blank" rel="noopener">https://oss.sonatype.org/content/groups/staging</a><br>please comment on this ticket when you promoted your first release, thanks</p></blockquote><p>然后通过下面的方法 Release，再次回复那个 issue，几分钟后又收到回复:</p><blockquote><p>Central sync is activated for com.linroid. After you successfully release, your component will be published to Central, typically within 10 minutes, though updates to search.maven.org can take up to two hours.</p></blockquote><h2 id="通过-gradle-mvn-push"><a href="#通过-gradle-mvn-push" class="headerlink" title="通过 gradle-mvn-push"></a>通过 gradle-mvn-push</h2><p> <a href="https://chris.banes.me/" target="_blank" rel="noopener">Chris Banes</a>大神很早前写了一个插件 <a href="https://github.com/chrisbanes/gradle-mvn-push" target="_blank" rel="noopener">gradle-mvn-push</a>(终于有机会用它了^﹏^)，让你通过一条gradle命令就可以自动构建好aar并提交到 Maven Central。下面介绍这个插件的使用方法。</p><ul><li><p>配置用于上传的<strong>认证信息</strong><br>配置文件默认在<code>${HOME}/.gradle/gradle.properties</code>，如果没有则自己创建。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NEXUS_USERNAME=linroid</span><br><span class="line">NEXUS_PASSWORD=YOUR_MAVEN_CENTRAL_PASSWORD</span><br><span class="line"></span><br><span class="line">signing.keyId=YOUR_GPG_KEY_ID</span><br><span class="line">signing.password=YOUR_GPG_PASSWORD</span><br><span class="line">signing.secretKeyRingFile=$&#123;HOME&#125;/.gnupg/secring.gpg</span><br></pre></td></tr></table></figure><p><code>NEXUS_USERNAME</code> 和 <code>NEXUS_PASSWORD</code> 是你注册的用户名和密码，下面的是用于 GPG 校验的配置信息，关于 GPG 的使用可以参见阮一峰的博文:<a href="http://www.ruanyifeng.com/blog/2013/07/gpg.html" target="_blank" rel="noopener">GPG 入门教程</a></p></li><li><p>配置<strong>版本信息</strong><br>在你的module目录创建<code>gradle.properties</code>文件，添加配置:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">POM_NAME=Android FilterMenu Library</span><br><span class="line">POM_ARTIFACT_ID=library</span><br><span class="line">POM_PACKAGING=aar</span><br><span class="line">VERSION_NAME=0.1.1</span><br><span class="line">VERSION_CODE=1</span><br><span class="line">GROUP=com.linroid.filtermenu</span><br><span class="line"></span><br><span class="line">POM_DESCRIPTION=Android FilterMenu Library</span><br><span class="line">POM_URL=https://github.com/linroid/FilterMenu</span><br><span class="line">POM_SCM_URL=https://github.com/linroid/FilterMenu</span><br><span class="line">POM_SCM_CONNECTION=scm:https://github.com/linroid/FilterMenu.git</span><br><span class="line">POM_SCM_DEV_CONNECTION=scm:https://github.com/linroid/FilterMenu.git</span><br><span class="line">POM_LICENCE_NAME=The Apache Software License, Version 2.0</span><br><span class="line">POM_LICENCE_URL=http://www.apache.org/licenses/LICENSE-2.0.txt</span><br><span class="line">POM_LICENCE_DIST=repo</span><br><span class="line">POM_DEVELOPER_ID=linroid</span><br><span class="line">POM_DEVELOPER_NAME=linroid</span><br><span class="line">POM_DEVELOPER_URL=http://linroid.com</span><br></pre></td></tr></table></figure><p>根据你的项目修改吧(‘・ω・’)</p></li><li><p><strong>添加gradle-mvn-push插件</strong><br>在 library module 的<code>build.gradle</code>文件中添加</p> <figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="string">from:</span> <span class="string">'https://raw.github.com/chrisbanes/gradle-mvn-push/master/gradle-mvn-push.gradle</span></span><br></pre></td></tr></table></figure><p>或者可以将 <a href="https://raw.githubusercontent.com/chrisbanes/gradle-mvn-push/master/gradle-mvn-push.gradle" target="_blank" rel="noopener">gradle-mvn-push.gradle</a> 文件下载下来，然后将上面的url该为本地路径。</p></li><li><p><strong>执行gradle task</strong><br>输入下面的命令，就可以自动构建并上传啦</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gradle clean build uploadArchives</span><br></pre></td></tr></table></figure><p>出现如下结果就说明上传成功了:）<br> <img src="http://7u2rtn.com1.z0.glb.clouddn.com/QQ20150313-2@2x.png" alt="执行成功"><br>还没结束，此时你的库并没有发布.</p></li><li><p><strong>最后一步</strong>：close staging repositories<br>登陆 <a href="https://oss.sonatype.org/" target="_blank" rel="noopener">Sonatype Nexus Professional</a> 点开左边 Build Promotion 的 Staging Repositories ，滚到最下面找到你最新上传的(可以点Content确保是你上传的)，选中之后点击上面的 <code>Close</code> 按钮 和 <code>Release</code> 按钮(多谢<a href="http://weibo.com/drak11t" target="_blank" rel="noopener">@drak11t</a>的提示)。</p><p>Ok 了，还需要等待一小段时间才能在 <a href="http://search.maven.org" target="_blank" rel="noopener">http://search.maven.org</a> 搜索到你的包。</p></li></ul><p>##链接</p><ul><li><a href="http://central.sonatype.org/pages/ossrh-guide.html" target="_blank" rel="noopener">OSSRH Guide</a> 官方指南</li><li><a href="http://www.ruanyifeng.com/blog/2013/07/gpg.html" target="_blank" rel="noopener">GPG 入门教程</a></li><li><a href="https://github.com/chrisbanes/gradle-mvn-push" target="_blank" rel="noopener">gradle-mvn-push</a> </li><li><a href="https://oss.sonatype.org/" target="_blank" rel="noopener">Sonatype Nexus Professional</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  将 &lt;a href=&quot;http://github.com/linroid/FilterMenu&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;FilterMenu&lt;/a&gt; 提交到 GitHub 后，在 README.md 的 Getting Started 里仅仅写上&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Download the source to use it as library project&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;  这唯一使用途径，居然没有 gradle/maven ?作为 Android Studio 的忠实用户，自己写的库怎么能只提供这么麻烦的方法！！！于是决定把它提交到 Maven Central 中。&lt;br&gt;
    
    </summary>
    
      <category term="瞎折腾" scheme="http://linroid.com/categories/%E7%9E%8E%E6%8A%98%E8%85%BE/"/>
    
    
      <category term="gradle" scheme="http://linroid.com/tags/gradle/"/>
    
  </entry>
  
  <entry>
    <title>四季电台</title>
    <link href="http://linroid.com/2015/02/11/sky31radio/"/>
    <id>http://linroid.com/2015/02/11/sky31radio/</id>
    <published>2015-02-11T05:12:23.000Z</published>
    <updated>2019-12-21T15:56:22.030Z</updated>
    
    <content type="html"><![CDATA[<!-- HTML --><p><blockquote class="blockquote-center"><br>躲在某一时间，想念一段时间的掌纹；躲在某一地点，聆听四季的声音。<br><img alt="四季电台主播列表截图" src="http://7u2rtn.com1.z0.glb.clouddn.com/device-2015-01-22-224820.png" width="300px"><br><a href="http://fir.im/sky31radio" target="_blank" rel="noopener">下载地址</a></blockquote></p><p><br><a id="more"></a><br>写完 <a href="http://radio.sky31.com" target="_blank" rel="noopener">http://radio.sky31.com</a> 的后台后，想把 app 也写出来.正好人机交互和 Java 也要交课程设计，就开始写了-.-<br>这次偷懒，数据缓存直接用 DiskLruCache 来管理没有使用数据库，也没有使用 MVP 模式.<br>播放器使用 SDK 中的 <a href="http://developer.android.com/reference/android/media/MediaPlayer.html" target="_blank" rel="noopener">MediaPlayer</a>实现，暂时还没实现播放缓存。<br>使用了如下的开源库：</p><ul><li><a href="http://jakewharton.github.io/butterknife/" target="_blank" rel="noopener">ButterKnife</a></li><li><a href="http://square.github.io/dagger/" target="_blank" rel="noopener">Dagger</a></li><li><a href="http://square.github.io/retrofit/" target="_blank" rel="noopener">Retrofit</a></li><li><a href="http://square.github.io/okhttp/" target="_blank" rel="noopener">OkHttp</a></li><li><a href="http://code.google.com/p/google-gson/" target="_blank" rel="noopener">Gson</a></li><li><a href="https://github.com/ReactiveX/RxAndroid" target="_blank" rel="noopener">RxAndroid</a></li><li><a href="https://github.com/jgilfelt/SystemBarTint" target="_blank" rel="noopener">SystemBarTint</a></li><li><a href="http://jakewharton.github.io/timber/" target="_blank" rel="noopener">Timber</a></li><li><a href="https://github.com/AnderWeb/discreteSeekBar" target="_blank" rel="noopener">DiscreteSeekBar</a></li></ul><p>源码放在 GitHub 上了，有兴趣的可以看看:): <a href="http://github.com/linroid/Sky31Radio" target="_blank" rel="noopener">Github地址</a></p>]]></content>
    
    <summary type="html">
    
      &lt;!-- HTML --&gt;
&lt;p&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;br&gt;躲在某一时间，想念一段时间的掌纹；躲在某一地点，聆听四季的声音。&lt;br&gt;&lt;img alt=&quot;四季电台主播列表截图&quot; src=&quot;http://7u2rtn.com1.z0.glb.clouddn.com/device-2015-01-22-224820.png&quot; width=&quot;300px&quot;&gt;&lt;br&gt;&lt;a href=&quot;http://fir.im/sky31radio&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;下载地址&lt;/a&gt;&lt;/blockquote&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;
    
    </summary>
    
      <category term="作品" scheme="http://linroid.com/categories/%E4%BD%9C%E5%93%81/"/>
    
    
      <category term="开源项目" scheme="http://linroid.com/tags/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
    
      <category term="四季电台" scheme="http://linroid.com/tags/%E5%9B%9B%E5%AD%A3%E7%94%B5%E5%8F%B0/"/>
    
  </entry>
  
  <entry>
    <title>调用 FragmentPagerAdapter 的 notifyDataSetChanged() 方法视图未更新</title>
    <link href="http://linroid.com/2015/01/29/view-not-updated-after-call-FragmentPagerAdapter-notifyDataSetChanged/"/>
    <id>http://linroid.com/2015/01/29/view-not-updated-after-call-FragmentPagerAdapter-notifyDataSetChanged/</id>
    <published>2015-01-29T13:54:39.000Z</published>
    <updated>2019-12-21T15:53:13.853Z</updated>
    
    <content type="html"><![CDATA[<p>学校在考完试后给我们加了一周的 Android 课，本来考完试很累了，还一天不让休息，天天起早去上课π__π。最后交课程设计, 模仿彩虹天气写一个天气应用,下面是我们组做的:<br><img src="https://cdn.linroid.com/media/view-not-updated-after-call-FragmentPagerAdapter-notifyDataSetChanged/device-2015-01-26-105356.png" width="300px"><br><a id="more"></a><br>城市切换使用的 ViewPager，以下是 FragmentPagerAdapter 里的一个方法，当 Loader 加载了新的 Cursor 后调用该方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCursor</span><span class="params">(Cursor cursor)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = cursor==<span class="keyword">null</span> ? <span class="number">0</span> : cursor.getCount();</span><br><span class="line">    Timber.d(<span class="string">"cursor count : %d"</span>, count);</span><br><span class="line">    weathers.clear();</span><br><span class="line">    <span class="keyword">if</span>(count==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;count; i++)&#123;</span><br><span class="line">        cursor.moveToPosition(i);</span><br><span class="line">        Weather weather = Weather.fromCursor(cursor);</span><br><span class="line">        weathers.add(weather);</span><br><span class="line">    &#125;</span><br><span class="line">    notifyDataSetChanged();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>想当然地像使用 ListView 的适配器一样调用 <code>notifyDataSetChanged()</code>,用但当添加删除城市后 ViewPager 里的视图并没有得到更新。Google 了下，Stackoverflow 里的一个回答让重写 getItemPosition() 方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getItemPosition</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> POSITION_NONE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加了之后，Fragment 的数目的确增加/删除了，但 Fragment 里的内容并没有更新，会出现两个一模一样的城市(因为我设置新增的城市显示在前面,不然就不会重复了)。<br>想了一下，既然是 fragment 应该不会不会像普通视图一样在数据更新后直接销毁掉，于是查看了 FragmentPagerAdapter 的源码。PagerAdapter 通过 <code>instantiateItem(ViewGroup container, int position)</code> 来获得一个视图, FragmentPagerAdapter 中的实现如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">instantiateItem</span><span class="params">(ViewGroup container, <span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mCurTransaction == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mCurTransaction = mFragmentManager.beginTransaction();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> itemId = getItemId(position);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do we already have this fragment?</span></span><br><span class="line">    String name = makeFragmentName(container.getId(), itemId);</span><br><span class="line">    Fragment fragment = mFragmentManager.findFragmentByTag(name);</span><br><span class="line">    <span class="keyword">if</span> (fragment != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"Attaching item #"</span> + itemId + <span class="string">": f="</span> + fragment);</span><br><span class="line">        mCurTransaction.attach(fragment);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fragment = getItem(position);</span><br><span class="line">        <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"Adding item #"</span> + itemId + <span class="string">": f="</span> + fragment);</span><br><span class="line">        mCurTransaction.add(container.getId(), fragment,</span><br><span class="line">                makeFragmentName(container.getId(), itemId));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fragment != mCurrentPrimaryItem) &#123;</span><br><span class="line">        fragment.setMenuVisibility(<span class="keyword">false</span>);</span><br><span class="line">        fragment.setUserVisibleHint(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fragment;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从中可以看出当在实例化 position 位置的 fragment 时，首先从 FragmentManager 查找在该 position 位置是否已经创建了 fragment，如果存在直接使用这个 fragment，从而达到复用.<br>假如现在有了三个城市A、B、C，position 分别为0、1、2.然后添加了一个城市 Z，Z 的 position为 0，C 为 3。FragmentManager 里已经存在了 position 为0,1,2的 fragment，所以前三个视图没有改变，但现在需要的 fragment 的数目变了，增加1。会创建 position 为3的 fragment，而此时是城市C，所以这样就会导致显示两次C，而新增的Z城市没有显示。<br>想起之前写 FragmentPagerAdapter 还会手动在 getItem() 方法里判断 Fragment 是否已经创建，完全没必要嘛, FragmentPagerAdapter 已经为我们做了这点-.-<br>解决的办法:<br>在通知数据更新之前从 FragmentManager 里移除所有 Fragment：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeALlFragments</span><span class="params">()</span></span>&#123;</span><br><span class="line">    FragmentTransaction transaction = fm.beginTransaction();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;fragments.size(); i++)&#123;</span><br><span class="line">        Fragment fg = fragments.get(i);</span><br><span class="line">        transaction.remove(fg);</span><br><span class="line">    &#125;</span><br><span class="line">    transaction.commit();</span><br><span class="line">    fragments.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样有些暴力了，毕竟创建一个 fragment 需要消耗较大的资源.决定重写 instantiateItem() 方法,当数据更新时，复用已有的 fragment，更新里面的数据。</p><ul><li><p>重写 <code>instantiateItem()</code> 方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">instantiateItem</span><span class="params">(ViewGroup container, <span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">    WeatherFragment fragment = (WeatherFragment) <span class="keyword">super</span>.instantiateItem(container, position);</span><br><span class="line">    Weather weather = weathers.get(position);</span><br><span class="line">    fragment.setWeatherData(weather);</span><br><span class="line">    <span class="keyword">return</span> fragment;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在 WeatherFragment 里添加下面的方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWeatherData</span><span class="params">(<span class="keyword">final</span> Weather weather)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.weather = weather;</span><br><span class="line">    <span class="keyword">if</span>(rootView==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学校在考完试后给我们加了一周的 Android 课，本来考完试很累了，还一天不让休息，天天起早去上课π__π。最后交课程设计, 模仿彩虹天气写一个天气应用,下面是我们组做的:&lt;br&gt;&lt;img src=&quot;https://cdn.linroid.com/media/view-not-updated-after-call-FragmentPagerAdapter-notifyDataSetChanged/device-2015-01-26-105356.png&quot; width=&quot;300px&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="遇过的坑" scheme="http://linroid.com/categories/%E9%81%87%E8%BF%87%E7%9A%84%E5%9D%91/"/>
    
    
      <category term="Fragment" scheme="http://linroid.com/tags/Fragment/"/>
    
  </entry>
  
  <entry>
    <title>Archlinux 下编译 AOSP 小记</title>
    <link href="http://linroid.com/2015/01/27/compile-aosp-on-archlinux/"/>
    <id>http://linroid.com/2015/01/27/compile-aosp-on-archlinux/</id>
    <published>2015-01-27T01:51:28.000Z</published>
    <updated>2019-12-21T15:53:13.851Z</updated>
    
    <content type="html"><![CDATA[<p>我用的是 fish shell，首先要进入到 bash shell:<br>    <code>bash</code><br>切换jdk版本到1.7<br>    <code>sudo archlinux-java set java-7-openjdk</code><br>切换python版本到2.x<br>    <code>sudo ln -sf /usr/bin/python2.7  /usr/bin/python</code><br>安装依赖库<br>    <code>yaourt -S libtinfo</code><br><a id="more"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我用的是 fish shell，首先要进入到 bash shell:&lt;br&gt;    &lt;code&gt;bash&lt;/code&gt;&lt;br&gt;切换jdk版本到1.7&lt;br&gt;    &lt;code&gt;sudo archlinux-java set java-7-openjdk&lt;/code&gt;&lt;br&gt;切换python版本到2.x&lt;br&gt;    &lt;code&gt;sudo ln -sf /usr/bin/python2.7  /usr/bin/python&lt;/code&gt;&lt;br&gt;安装依赖库&lt;br&gt;    &lt;code&gt;yaourt -S libtinfo&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
      <category term="瞎折腾" scheme="http://linroid.com/categories/%E7%9E%8E%E6%8A%98%E8%85%BE/"/>
    
    
      <category term="linux" scheme="http://linroid.com/tags/linux/"/>
    
      <category term="AOSP" scheme="http://linroid.com/tags/AOSP/"/>
    
  </entry>
  
  <entry>
    <title>利用 GitHub 的 Webhook 部署博客</title>
    <link href="http://linroid.com/2015/01/21/using-github-webhook-to-deploy-my-blog/"/>
    <id>http://linroid.com/2015/01/21/using-github-webhook-to-deploy-my-blog/</id>
    <published>2015-01-20T16:01:28.000Z</published>
    <updated>2019-12-21T15:53:13.853Z</updated>
    
    <content type="html"><![CDATA[<p>GitHub 现在比较难打开了，决定把博客放到自己的 vps 上。<br>当又想同步到 GitHub 上，如果每次都要手动到 vps 上执行 pull，那太麻烦了！！！<br>GitHub 的仓库可以设置 <code>Webhook</code>，当收到 push 后会通知到设定的 url，救星来啦～～～<br><a id="more"></a><br>看了下 api 文档，用 php 写了 <code>git-hook.php</code> 文件放到博客目录下:<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">error_reporting(<span class="number">7</span>);</span><br><span class="line">date_default_timezone_set(<span class="string">'UTC'</span>);</span><br><span class="line">define(<span class="string">"WWW_ROOT"</span>, <span class="string">"/www/linroid.com/"</span>);</span><br><span class="line">define(<span class="string">"LOG_FILE"</span>, <span class="string">"/www/logs/linroid.com/git-hook.log"</span>);</span><br><span class="line">$shell = sprintf(<span class="string">"cd %s &amp;&amp; /usr/bin/git pull 2&gt;&amp;1"</span>, WWW_ROOT);</span><br><span class="line">$output = shell_exec($shell);</span><br><span class="line">$log = sprintf(<span class="string">"[%s] %s \n"</span>, date(<span class="string">'Y-m-d H:i:s'</span>, time()), $output);</span><br><span class="line"><span class="keyword">echo</span> $log;</span><br><span class="line">file_put_contents(LOG_FILE, $log, FILE_APPEND);</span><br></pre></td></tr></table></figure></p><p>通过 ssh 执行 <code>php git-hook.php</code> 成功，但 url 访问时失败了。vps 上是通过 php-fpm 执行 php 的，用户为 <code>www-data</code>，shell 为<code>/usr/sbin/nologin</code>,会找不到 git 命令,需要使用 git 的绝对路径:<br><code>$shell = sprintf(&quot;cd %s &amp;&amp; /usr/bin/git pull&quot;, WWW_ROOT);</code></p><p>出现权限问题<br><code>error: cannot open .git/FETCH_HEAD: Permission denied</code></p><p>修改目录所属：<br><code>sudo chown  -R www-data:www-data ./linroid.com</code></p><p>在仓库的webhook里添加url <code>http://linroid.com/git-hook.php</code>,然后 vps 就可以从 GitHub 自动 pull 了~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;GitHub 现在比较难打开了，决定把博客放到自己的 vps 上。&lt;br&gt;当又想同步到 GitHub 上，如果每次都要手动到 vps 上执行 pull，那太麻烦了！！！&lt;br&gt;GitHub 的仓库可以设置 &lt;code&gt;Webhook&lt;/code&gt;，当收到 push 后会通知到设定的 url，救星来啦～～～&lt;br&gt;
    
    </summary>
    
      <category term="瞎折腾" scheme="http://linroid.com/categories/%E7%9E%8E%E6%8A%98%E8%85%BE/"/>
    
    
      <category term="Blog" scheme="http://linroid.com/tags/Blog/"/>
    
      <category term="Github" scheme="http://linroid.com/tags/Github/"/>
    
  </entry>
  
  <entry>
    <title>使用 NameCheap 的 SSL 证书</title>
    <link href="http://linroid.com/2014/12/21/setting-up-ssl-with-nginx-using-a-namecheap-essentialssl/"/>
    <id>http://linroid.com/2014/12/21/setting-up-ssl-with-nginx-using-a-namecheap-essentialssl/</id>
    <published>2014-12-20T17:14:35.000Z</published>
    <updated>2019-12-21T15:53:13.852Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/media/setting-up-ssl-with-nginx-using-a-namecheap-essentialssl/20141221121928.png" alt="使用NameCheap的SSL证书"><br>利用之前申请了 GitHub 的学生礼包免费注册了 [alwen.me] 域名，另外一年免费的 ssl 证书也申请了.<br><a id="more"></a><br>在服务器上生成用于申请证书的 CSR 和私钥<br><code>openssl req -new -nodes -keyout alwen_me.key -out alwen_me.csr</code><br>将 csr 交到 NameCheap，数小时后 <a href="mailto:webmaster@alwen.me" target="_blank" rel="noopener">webmaster@alwen.me</a> 收到了来自 Comodo 的域名控制权验证邮件，完成验证后，管理员邮箱就会收到 PositiveSSL 证书了<br>附件中一共包含四个文件：</p><ul><li>Root CA Certificate - AddTrustExternalCARoot.crt</li><li>Intermediate CA Certificate - COMODORSAAddTrustCA.crt</li><li>Intermediate CA Certificate - COMODORSADomainValidationSecureServerCA.crt</li><li>Your PositiveSSL Certificate - alwen_me.crt</li></ul><p>需要将这几个密钥放到一个文件中:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat alwen_me.crt COMODORSADomainValidationSecureServerCA.crt COMODORSAAddTrustCA.crt AddTrustExternalCARoot.crt &gt; ssl_bundle.cer</span><br></pre></td></tr></table></figure></p><p>接下来就是设置 nginx 配置文件开启 ssl 了:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># HTTPS server</span><br><span class="line">server &#123;</span><br><span class="line">listen 443;</span><br><span class="line">server_name alwen.me;</span><br><span class="line"></span><br><span class="line">root /www/alwen/;</span><br><span class="line">index index.html index.htm;</span><br><span class="line"></span><br><span class="line">ssl on;</span><br><span class="line">ssl_certificate ssl/ssl_bundle.crt;</span><br><span class="line">ssl_certificate_key ssl/alwen_me.key;</span><br><span class="line"></span><br><span class="line">ssl_session_timeout 5m;</span><br><span class="line"></span><br><span class="line">ssl_protocols SSLv3 TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">ssl_ciphers &quot;HIGH:!aNULL:!MD5 or HIGH:!aNULL:!MD5:!3DES&quot;;</span><br><span class="line">ssl_prefer_server_ciphers on;</span><br><span class="line"></span><br><span class="line">location / &#123;</span><br><span class="line">try_files $uri $uri/ =404;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>并且将 http 访问跳转至 https 连接：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  server_name alwen.me www.alwen.me;</span><br><span class="line">  return 301 https://alwen.me$request_uri;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>大功告成(&gt;▽&lt;)，现在访问 <a href="https://alwen.me" target="_blank" rel="noopener">alwen.me</a> 浏览器就显示出安全标志了.<br>必须感谢 GitHub 提供的 <a href="https://education.github.com/pack" target="_blank" rel="noopener">学生礼包</a> 啊，还有100美刀的 DigitalOcean 消费劵用来作梯子再好不过啦～不过现在好像国内的 .edu 邮箱被屏蔽，申请不了了 &gt;﹏&lt;</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/media/setting-up-ssl-with-nginx-using-a-namecheap-essentialssl/20141221121928.png&quot; alt=&quot;使用NameCheap的SSL证书&quot;&gt;&lt;br&gt;利用之前申请了 GitHub 的学生礼包免费注册了 [alwen.me] 域名，另外一年免费的 ssl 证书也申请了.&lt;br&gt;
    
    </summary>
    
      <category term="瞎折腾" scheme="http://linroid.com/categories/%E7%9E%8E%E6%8A%98%E8%85%BE/"/>
    
    
      <category term="Blog" scheme="http://linroid.com/tags/Blog/"/>
    
  </entry>
  
  <entry>
    <title>大半年没写博客了T_T</title>
    <link href="http://linroid.com/2014/12/21/no-writing-so-long/"/>
    <id>http://linroid.com/2014/12/21/no-writing-so-long/</id>
    <published>2014-12-20T16:50:33.000Z</published>
    <updated>2019-12-21T15:53:13.852Z</updated>
    
    <content type="html"><![CDATA[<p>之前用 Octopress 在 GitHub 上写了几篇，重装系统后配置出现了问题，就很久懒得动它了。之后用了 hexo 重新搭建后一直搁置着也没动(Octopress 的博文可以直接迁移到 Hexo，赞！)。<br>还是要写写，那我就随便写吧ヾ(●´▽｀●)ノ<br><a id="more"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前用 Octopress 在 GitHub 上写了几篇，重装系统后配置出现了问题，就很久懒得动它了。之后用了 hexo 重新搭建后一直搁置着也没动(Octopress 的博文可以直接迁移到 Hexo，赞！)。&lt;br&gt;还是要写写，那我就随便写吧ヾ(●´▽｀●)ノ&lt;br&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://linroid.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="Blog" scheme="http://linroid.com/tags/Blog/"/>
    
  </entry>
  
  <entry>
    <title>Google 发布的官方刷新组件：SwipeRefreshLayout</title>
    <link href="http://linroid.com/2014/04/08/2014-04-08-google_offical_refresh_widget/"/>
    <id>http://linroid.com/2014/04/08/2014-04-08-google_offical_refresh_widget/</id>
    <published>2014-04-08T10:12:00.000Z</published>
    <updated>2019-12-21T15:53:13.848Z</updated>
    
    <content type="html"><![CDATA[<p>谷歌终于发布了官方的下拉刷新组件：<a href="http://developer.android.com/reference/android/support/v4/widget/SwipeRefreshLayout.html" target="_blank" rel="noopener">SwipeRefreshLayout</a>，它被包含在了19.1.0版本的Support Library中。<code>SwipeRefreshLayout</code>在使用上非常简单,只需要把要刷新的可滚动组件放到<code>SwipeRefreshLayout</code> 中,<br><a id="more"></a><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">android.support.v4.widget.SwipeRefreshLayout</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/swipe_container"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="name">ScrollView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">        <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:text</span>=<span class="string">"@string/hello_world"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_marginTop</span>=<span class="string">"16dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:gravity</span>=<span class="string">"center"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ScrollView</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">android.support.v4.widget.SwipeRefreshLayout</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>然后调用<code>setOnRefreshListener(OnRefreshListener listener)</code> 和 <code>setColorScheme(int colorRes1, int colorRes2, int colorRes3, int colorRes4)</code>两个方法进行设置，在OnRefreshListener中实现<code>onRefresh()</code>方法即可:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line"> </span><br><span class="line">    swipeLayout = (SwipeRefreshLayout) findViewById(R.id.swipe_container);</span><br><span class="line">    swipeLayout.setOnRefreshListener(<span class="keyword">this</span>);</span><br><span class="line">    swipeLayout.setColorScheme(android.R.color.holo_blue_bright, </span><br><span class="line">            android.R.color.holo_green_light, </span><br><span class="line">            android.R.color.holo_orange_light, </span><br><span class="line">            android.R.color.holo_red_light);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Handler().postDelayed(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            swipeLayout.setRefreshing(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">5000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>SwipeRefreshLayout</code>实现了Google Now中刷新的风格，与之类似的有一个开源库<a href="https://github.com/chrisbanes/ActionBar-PullToRefresh" target="_blank" rel="noopener">ActionBar-PullToRefresh</a>则实现了Google Plus的风格。<br><img src="/media/2014-04-08-google_offical_refresh_widget/google_now_refresh_style.png" alt="google_now_refresh_style"><br>Google Now即时卡贴中的刷新<br><img src="/media/2014-04-08-google_offical_refresh_widget/google_plus_refresh_style.png" alt="google_plus_refresh_style"><br>Google Plus中的刷新<br>虽然<code>ActionBar-PullToRefresh</code>的开发者在前不久建议大家使用<code>SwipeRefreshLayout</code>但是比较一下两者还是有一定的区别，SwipeRefreshLayout并不能完全取代</p><ul><li>位置不同：ActionBar-PullToRefresh的刷新进度条始终在ActionBar底部，SwipeRefreshLayout的进度条在要刷新组件的顶部。</li><li>ActionBar-PullToRefresh在下拉的时候ActionBar会设置相应的文字指示，而SwipeRefreshLayout则只是把被滚动的组件随着手指的移动向下滑动。<br>SwipeRefreshLayout会强制填充整个父容器，对其设置<code>layout_height</code> 和 <code>layout_width</code>无效，如果要在当前布局中显示其他非要被刷新的组件，则需要给SwipeRefreshLayout外套一个父容器:<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;RelativeLayout</span><br><span class="line">    xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    xmlns:tools=<span class="string">"http://schemas.android.com/tools"</span></span><br><span class="line">    android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">    android:layout_height=<span class="string">"match_parent"</span></span><br><span class="line">    tools:context=<span class="string">"com.xtuers.android.ui.question.DetailActivity"</span>&gt;</span><br><span class="line">    &lt;FrameLayout</span><br><span class="line">        android:layout_alignParentTop=<span class="string">"true"</span></span><br><span class="line">        android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">        android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">        android:layout_above=<span class="string">"@+id/answer_bottom_container"</span></span><br><span class="line">        &gt;</span><br><span class="line">        &lt;android.support.v4.widget.SwipeRefreshLayout</span><br><span class="line">            android:id=<span class="string">"@id/swipe_refresh_container"</span></span><br><span class="line">            android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">            android:layout_height=<span class="string">"match_parent"</span>&gt;</span><br><span class="line">            &lt;ListView</span><br><span class="line">                android:id=<span class="string">"@+id/answer_list"</span></span><br><span class="line">                android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">                android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">                android:divider=<span class="string">"@android:color/transparent"</span>/&gt;</span><br><span class="line">        &lt;/android.support.v4.widget.SwipeRefreshLayout&gt;</span><br><span class="line">    &lt;/FrameLayout&gt;</span><br><span class="line">...</span><br><span class="line">&lt;/RelativeLayout&gt;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;谷歌终于发布了官方的下拉刷新组件：&lt;a href=&quot;http://developer.android.com/reference/android/support/v4/widget/SwipeRefreshLayout.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SwipeRefreshLayout&lt;/a&gt;，它被包含在了19.1.0版本的Support Library中。&lt;code&gt;SwipeRefreshLayout&lt;/code&gt;在使用上非常简单,只需要把要刷新的可滚动组件放到&lt;code&gt;SwipeRefreshLayout&lt;/code&gt; 中,&lt;br&gt;
    
    </summary>
    
      <category term="瞎折腾" scheme="http://linroid.com/categories/%E7%9E%8E%E6%8A%98%E8%85%BE/"/>
    
    
      <category term="Android" scheme="http://linroid.com/tags/Android/"/>
    
      <category term="SwipeRefreshLayout" scheme="http://linroid.com/tags/SwipeRefreshLayout/"/>
    
  </entry>
  
</feed>
