<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Activity 的 onStop 居然需要 10s 才会被执行？ · linroid</title><meta name="description" content="Activity 的 onStop 居然需要 10s 才会被执行？ - linroid"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://linroid.com/atom.xml" title="linroid"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/avatar.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">Blog</a></li><li class="nav-list-item"><a href="/products/" target="_self" class="nav-list-link">Products</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">Archives</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">About</a></li><li class="nav-list-item"><a href="https://instagram.com/linroid/" target="_blank" class="nav-list-link">Instagram</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Activity 的 onStop 居然需要 10s 才会被执行？</h1><div class="post-info">Aug 10, 2018</div><div class="post-content"><p>由于我们的应用依赖 Activity 的 onStop 来停止播放器，近期发现退出直播间后，声音居然残留10s 左右，通过日志发现 Activity 的 onStop 在退出界面后需要10s左右才会被执行，该如何定位这个问题呢？<br><a id="more"></a><br>Activity 的 onStop 是放到 <code>IdleHandler</code> 执行的，所以退出界面后 onStop 不会立即执行，而是等到主线程中当前没有消息要执行的时候才会执行，具体可见我的另一篇文章分析：<a href="https://linroid.com/2017/05/24/Pit-of-Activity-destory/">Activity 销毁的延迟</a>。但必现 10s 左右才被执行肯定是异常的，可能有消息导致主线程一直没有 处理 IdleHandler，为验证这一点，可以在 onPause 的时候添加一个 IdleHandler 到主线程消息队列中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onPause();</span><br><span class="line">    Looper.myQueue().addIdleHandler(<span class="keyword">new</span> MessageQueue.IdleHandler() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">queueIdle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Log.i(TAG, <span class="string">"queueIdle after onPause"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果果然是在 onStop 之后才会被执行，所以可以确认是由于主线程一直有没有执行 IdleHandler 导致的，初步怀疑是有地方一直在往主线程 Looper 中 添加消息，接下来就需要定位是什么消息导致主线程一直处于非空闲状态。</p>
<p>我们可以通过 <code>Looper.setMessageLogging()</code> 来打印出主线程中执行的消息:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Looper.getMainLooper().setMessageLogging(<span class="keyword">new</span> Printer() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(String x)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (x.startsWith(<span class="string">"&gt;&gt;&gt;&gt;&gt;"</span>)) &#123;</span><br><span class="line">                Log.d(TAG, x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现有个动画组件的消息不停地被执行，移除这个动画组件后，问题依然存在，并且未发现其他比较明显的异常消息。</p>
<p><img src="https://cdn.linroid.com/WX20180723-105051@2x.png" alt></p>
<p>既然主线程中一直非空闲状态，那么我们就把主线程消息队列中的所有消息打印出来看看？</p>
<p>通过反射，可在每一帧的时候打印出主线程消息队列中的所有消息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Field messagesField;</span><br><span class="line"><span class="keyword">private</span> Field nextField;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        messagesField = MessageQueue.class.getDeclaredField("mMessages");</span><br><span class="line">        messagesField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        nextField = Message.class.getDeclaredField("next");</span><br><span class="line">        nextField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span> </span>&#123;        </span><br><span class="line">	Choreographer.getInstance().postFrameCallback(<span class="keyword">new</span> Choreographer.FrameCallback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFrame</span><span class="params">(<span class="keyword">long</span> frameTimeNanos)</span> </span>&#123;</span><br><span class="line">                Choreographer.getInstance().postFrameCallback(<span class="keyword">this</span>);</span><br><span class="line">                Log.d(TAG, <span class="string">"doFrame"</span>);</span><br><span class="line">                printMessages();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printMessages</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MessageQueue queue = Looper.myQueue();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Message msg = (Message) messagesField.get(queue);</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span> (msg != <span class="keyword">null</span>) &#123;</span><br><span class="line">            sb.append(msg.toString());</span><br><span class="line">            sb.append(<span class="string">"\n"</span>);</span><br><span class="line">            msg = (Message) nextField.get(msg);</span><br><span class="line">        &#125;</span><br><span class="line">        Log.i(TAG, sb.toString());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>得到如下日志：<br><img src="https://cdn.linroid.com/blog/WX20180723-105818@2x.png" alt><br>可以看到消息队列的头部始终是一个 SyncBarrier 消息，有这个消息存在的时候，MessageQueue 只会取下一个 异步消息，让系统的 UI 事件消息得到优先处理。由此猜测，有地方不停地向 MessageQueue 中添加 SyncBarrier，通过对 <code>MessageQueue#postSyncBarrier()</code>方法打调试断点后，终于发现了罪魁祸首。</p>
<p><img src="https://cdn.linroid.com/blog/WX20180723-193912@2x.png" alt></p>
<p>查看代码后发现，虽然这位童鞋在收到 onGlobalLayout() 回调时的确调用了<code>View.getViewTreeObserver().removeOnGlobalLayoutListener()</code> ，但在上面截图中的 <code>fixBtnLayout</code>方法中又把监听器重新添加上了，所以实际并没有成功移除，相当于这里出现一个“异步的死循环“。</p>
<p>在 OnGlobalLayoutListener 中更新了布局的 LayoutParams 导致触发了 requestLayout()，而 requestLayout 会调用 <code>MessageQueue#postSyncBarrier()</code>，至于为什么主线程中有 SyncBarrier 消息时，IdleHandler 没有被执行的原因可以看 <code>MessageQueue#next()</code>的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If first time idle, then get the number of idlers to run.</span></span><br><span class="line"><span class="comment">// Idle handles only run if the queue is empty or if the first message</span></span><br><span class="line"><span class="comment">// in the queue (possibly a barrier) is due to be handled in the future.</span></span><br><span class="line"><span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span></span><br><span class="line">    &amp;&amp; (mMessages == <span class="keyword">null</span> || now &lt; mMessages.when)) &#123;</span><br><span class="line">    pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// No idle handlers to run.  Loop and wait some more.</span></span><br><span class="line">    mBlocked = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于这个时候是有消息的，所以 mMessages != null，由上面的日志可以看到 消息队列头部消息始终是 when 为负值，导致 <code>now &lt; mMessages.when</code> 也不成立，所以 pendingIdleHandlerCount 会一直为0，直到调用了 <code>MessageQueue#removeSyncBarrier()</code> 来移除 SyncBarrier 消息。</p>
<p>那么为什么 Activity 还是能回调 <code>onStop()</code> 呢？过滤掉 ActivityManager 的消息后可以看到一条这样的日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">W/ActivityManager: Launch timeout has expired, giving up wake lock!</span><br></pre></td></tr></table></figure>
<p>这是 ActivityManagerService 的超时机制，而这个时间正好是10s，具体可见 ActivityStack 中 <code>STOP_TIMEOUT</code>。超时后会把 Activity 强制置为 stop 状态，这时候不会再触发 onGlobalLayout，从而不会再有 SyncBarrier 消息，所以最终 IdleHandler 得到执行的机会。</p>
<h2 id="相关源码"><a href="#相关源码" class="headerlink" title="相关源码"></a>相关源码</h2><ul>
<li><a href="https://android.googlesource.com/platform/frameworks/base.git/+/master/services/core/java/com/android/server/am/ActivityStack.java" target="_blank" rel="noopener">ActivityStack.java</a></li>
<li><a href="https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/os/MessageQueue.java" target="_blank" rel="noopener">MessageQueue.java</a></li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/2017/05/24/Pit-of-Activity-destory/" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'linroid';
var disqus_identifier = '2018/08/10/onStop-executed-too-slowly/';
var disqus_title = 'Activity 的 onStop 居然需要 10s 才会被执行？';
var disqus_url = 'http://linroid.com/2018/08/10/onStop-executed-too-slowly/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//linroid.disqus.com/count.js" async></script><div class="copyright"><p>© 2013 - 2019 <a href="http://linroid.com">linroid</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a> <a href="http://beian.miit.gov.cn" target="_blank">粤ICP备17156215号</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-50624084-1",'auto');ga('send','pageview');</script></body></html>