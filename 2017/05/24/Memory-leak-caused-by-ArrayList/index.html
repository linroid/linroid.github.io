<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> ArrayList 导致的内存泄露 · linroid</title><meta name="description" content="ArrayList 导致的内存泄露 - linroid"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://linroid.com/atom.xml" title="linroid"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/avatar.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">Blog</a></li><li class="nav-list-item"><a href="/products/" target="_self" class="nav-list-link">Products</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">Archives</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">About</a></li><li class="nav-list-item"><a href="https://instagram.com/linroid/" target="_blank" class="nav-list-link">Instagram</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">ArrayList 导致的内存泄露</h1><div class="post-info">May 24, 2017</div><div class="post-content"><p>前段时间在排查一处内存泄露时，发现是注册的一个监听器导致的。但检查了这个监听器在该取消注册的地方的确取消注册了，那内存中为什么还有它的引用呢？</p>
<a id="more"></a>
<p>分析内存发现是 ArrayList 对它进行了持有，但的确调用了 remove 来移除这个监听器呀。打断点发现注册监听器的方法被调用了两次，即调用了两次 ArrayList 的 add 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ArrayList 的 add 方法并没有进行去重操作，所以两次 add 都会成功。但 remove 方法却只调用了一次，来看看 remove 的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，remove 方法会遍历数组中的元素，一旦找到这个监听器，就会 return，即一次 remove 只会移除一个引用。但我们调用了两次 add 方法，所以 ArrayList 依然持有 这个监听器的引用。</p>
<h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><ul>
<li>在 add 的时候判断下 ArrayList 中是否已经存在这个对象，如果有则忽略这次操作</li>
<li>使用 HashSet 代替 ArrayList，HashSet 在添加的时候会进行去重</li>
</ul>
<h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><p>  其实使用 ArrayList 来作为存放监听器的集合是很常见的，比如在 <code>RecyclerView</code>中 <code>mItemDecorations</code>、<code>mOnItemTouchListeners</code>、<code>mOnChildAttachStateListeners</code>、<br>  <code>mPendingAccessibilityImportanceChange</code>、<code>mScrollListeners</code> 等属性都是使用 ArrayList 来保存的，并且没有做去重处理。如果这个 ArrayList 放在单例中并且只 remove 了一次，重复的添加就会导致内存泄露；而在使用时的遍历又会因重复调用导致性能或其他问题。</p>
<p>  所以我们平时在遇到往 ArrayList 中添加对象时一定要注意这点，当然我个人更建议使用 HashSet 来保存，这样可以更好地避免团队里其他成员在使用时出现问题。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2017/05/24/Pit-of-Activity-destory/" class="prev">PREV</a><a href="/2017/03/19/introduce-wrapper/" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'linroid';
var disqus_identifier = '2017/05/24/Memory-leak-caused-by-ArrayList/';
var disqus_title = 'ArrayList 导致的内存泄露';
var disqus_url = 'http://linroid.com/2017/05/24/Memory-leak-caused-by-ArrayList/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//linroid.disqus.com/count.js" async></script><div class="copyright"><p>© 2013 - 2020 <a href="http://linroid.com">linroid</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a> <a href="http://beian.miit.gov.cn" target="_blank">粤ICP备17156215号</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-50624084-1",'auto');ga('send','pageview');</script></body></html>